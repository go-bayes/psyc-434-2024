---
title: "Causal Inference: Estimation of ATE and CATE"
date: "2023-APR-28"
format:
  html:
    warnings: FALSE
    error: FALSE
    messages: FALSE
    code-overflow: scroll
    highlight-style: oblivion
    code-tools:
      source: true
      toggle: FALSE
html-math-method: katex
reference-location: margin
citation-location: margin
cap-location: margin
code-block-border-left: true
---

```{r}
#| include: false
# for information about this template: https://github.com/mikemahoney218/quarto-arxiv/blob/main/template.qmd
#libraries and functions
# read libraries
library("tinytex")
library(extrafont)
loadfonts(device = "win")

# read functions
#source("/Users/joseph/GIT/templates/functions/funs.R")
```


::: {.callout-note}
**Required**
- [@vanderweele2020] [link](https://www.dropbox.com/scl/fi/srpynr0dvjcndveplcydn/OutcomeWide_StatisticalScience.pdf?rlkey=h4fv32oyjegdfl3jq9u1fifc3&dl=0)


**Optional**
- [@suzuki2020] [link](https://www.dropbox.com/scl/fi/4midxwr9ltg9oce02e0ss/suzuki-causal-diagrams.pdf?rlkey=uktzf3nurtgpbj8m4h0xz82dn&dl=0)
- [@Bulbulia2024PracticalGuide] [link](https://osf.io/preprints/psyarxiv/uyg3d)
- [@hoffman2023] [link](https://arxiv.org/pdf/2304.09460.pdf)
:::

::: {.callout-important}
## Key concepts for the test(s):
  - **Counfounding vs Confounder**
  - **Causal Estimand, Statistical Estimand, Statistical Estimator**
  - **Inverse probabilitiy of treatment weights using propensity scores: modelling the exposure or treatment, not the outcome.**
  - **Subgroup analysis using propensity scores**
:::

::: {.callout-important}
## For the lab, copy and paste code chunks following the "LAB" section.
:::


# Seminar

## Learning Outcomes

- You will learn how to state a causal question in a three-wave panel
- You will learn how to identify causal effects in a three-waves of panel data.
- How to do Propensity-score weighting: modelling the exposure or treatment, not the outcome.
<!-- - Outcome modelling: modelling the outcome, with the treatment included in the model -->
<!-- - Doubly robust estimation: model both the treatment and the outcome.** -->
- Subgroup analysis by doubly-robust estimation


<!-- - You will learn how to write a report statement that formulates a causal question, names a population of interest, and constructs a causal diagram that explains whether and how to identify a causal effect from data.  -->


### Why is this lesson important?

<!-- Recall that in psychology, our task is to answer some questions about how people think and behave. In cross-cultural psychology, these questions are typically comparative. -->

<!-- Our first task is clearly define that question. Our second task is to answer that question. -->

The methods you will learn today will help you to define and answer comparative questions in psychology. 


## Review: The Fundamental Problem of Causal Inference as a Missing Data Problem

Recall the fundamental problem of causal inference, returning to the question of whether bilingualism improves cognitive abilities:

-   $Y_i^{a = 1}$: The cognitive ability of child $i$ if they were bilingual. This is the counterfactual outcome when A = 1.
-   $Y_i^{a = 0}$:: The cognitive ability of child $i$ if they were monolingual. This is the counterfactual outcome when A = 0.

The causal effect of bilingualism on cognitive ability for individual $i$ is then defined as the difference between these potential outcomes:

$$
\text{Causal Effect}_i = Y_i^{a=1} - Y_i^{a=0} 
$$

We say there is a causal effect if:

$$
Y_i^{a=1} - Y_i^{a=0}  \neq 0
$$

However, we only observe one of the potential outcomes for each child. The other outcome is not observed because physics prevents a child from both receiving and not receiving bilingual exposure.

The fact that causal contrasts are not observed in individuals is called "The fundamental problem of causal inference."

Although we typically cannot observe individual causal effects, we can obtain average causal effects when certain assumptions are satisfied.

```{=tex}
\begin{align}
E(\delta) = E(Y^{a=1} - Y^{a=0})\\
          ~  = E(Y^{a=1}) - E(Y^{a=0}) \\
          ~  = ATE
\end{align}
```
We may identify average causal effects from the data when the following assumptions are met:

-   **Causal Consistency:** The exposure values under comparisons correspond to well-defined interventions that, in turn, correspond to the treatment versions in the data.[]
-   **Positivity:** The probability of receiving every value of the exposure within all strata of co-variates is greater than zero []
-   **Exchangeability:** The conditional probability of receiving every value of an exposure level, though not decided by the investigators, depends only on the measured covariates []

Further assumptions:

-   **No Interference,** also known as the **Stable Unit Treatment Value Assumption** (SUTVA), requires that the treatment given to one unit (e.g., person, group, organization) does not interfere with the potential outcomes of another unit. Put differently, there are no "spillover" effects. Note: this assumption may be thought to be part of causal consistency, namely individual has only one potential outcome under each treatment condition.
-   **Correctly specified model**: the requirement that the underlying statistical model used to estimate causal effects accurately represents the true relationships between the variables of interest. We say the model should be able to capture "the functional form" of the relationship between the treatment, the outcome, and any covariates. The model's functional form should be flexible enough to capture the true underlying relationship. The estimated causal effects may be biased if the model's functional form is incorrect. Additionally, the model must handle omitted variable bias by including all relevant confounders and should correctly handle missing data from non-response or loss-to follow up. We will return to the bias arising from missing data in the weeks ahead. For now, it is important to note that causal inference assumes that our model is correctly specified.


## Subgroup analysis

<!-- In causal inference, these two concepts are related but have distinct meanings. -->

<!-- Let $Y_{a}$ denote the counterfactual outcome Y when the experimental intervention $A$ is set to level $a$. Let $Y_{r}$ denote the counterfactual outcome $Y$ when another experimental intervention $R$ is set to level $r$. Following VanderWeele (2009), we can define interaction and effect modification as follows: -->

<!-- 1.  Interaction (causal interaction) on the difference scale, conditional on confounders $L$, occurs when: -->

<!-- $$E(Y^{a1,r1}|L=l) - E(Y^{a0,r1}|L=l) \neq E(Y^{a1,r0}|L=l) - E(Y^{a0,r0}|L=l)$$ -->

<!-- In this case, we are considering a double intervention, and interaction occurs when the combined effect of interventions $A$ and $R$ is not equal to the sum of their individual effects. -->

Redcall, **Effect Modification** (also known as "heterogeneity of treatment effects", and "Effect-measure modification") occurs when the causal effect of intervention $A$ varies across different levels of another variable $R$:

$$E(Y^{a=1}|G=g_1, L=l) - E(Y^{a=0}|G=g_1, L=l) \neq E(Y^{a=1}|G=g_2, L=l) - E(Y^{a=0}|G=g_2, L=l)$$

Effect modification indicates that the magnitude of the causal effect of intervention $A$ is related to the modifier variable $G$ level. As discussed last week, effect modification can be observed even when there is no direct causal interaction between the treatment and the modifier variable. We noted that **interaction in causal inference refers to a situation where the combined effect of two interventions is not equal to the sum of their individual effects**. **Effect modification, on the other hand, occurs when the causal effect of one intervention varies across different levels of another variable.**


We also noted that 

> **For comparative research, we are typically interested in effect-modification, which requires subgroup analysis.**


### Causal Estimand, Statistical Estimand, Statistical Estimator

Let's set subgroup analysis to the side for a moment and begin focussing on statistical estimation.  

Suppose a researcher wants to understand the causal effect of marriage on individual happiness. Participants in the study are surveyed for their marital status ("married" or "not married") and their self-reported happiness on a scale from 1 to 10.

#### Causal Estimand

- **Definition**: The causal estimand is the specific quantity or parameter that we aim to estimate to understand the causal effect of an intervention or treatment on an outcome.

- **Example**: Here, the **Causal Estimand** would be the Average Treatment Effect (ATE) of being married on happiness. Specifically, we define the ATE as the difference in the potential outcomes of happiness if all individuals were married versus if no individuals were married:

  $$
  \text{ATE} = E[Y^{a=1} - Y^{a=0}]
  $$


  Here, $Y^{a=1}$ represents the potential happiness score if an individual is married, and $Y^{a=0}$ if they are not married.


#### Next step: Are Causal Assumptions Met? 

- Identification (Exchangeability): balance in the confounders across the treatments to be compared

- Consistency: well-defined interventions

- Positivity: treatments occur within levels of covariates $L$


#### Statistical Estimand (next step)

- **The problem**: how do we bridge the gap between potential outcomes and data? 

- **Definition**: the statistical estimand is the parameter or function that summarises the relationship between variables as described by a statistical model applied to data. 

- **Example**: for our study, the **Statistical Estimand** might be the mean difference in happiness scores between individuals who are married and those who are not, as derived from a linear regression model:

  $$
  \text{Happiness} = \beta_0 + \beta_1 \times \text{Married} + \epsilon
  $$

  In this equation, $\beta_1$ represents the estimated difference in happiness scores between the married and non-married groups.

#### Statistical Estimator

- **Definition**: a statistical estimator is a rule or method by which a numerical estimate of a statistical estimand is calculated from the data.

- **Example**: in our marriage study, the **Statistical Estimator** for $\beta_1$ is the ordinary least squares (OLS) estimator. This estimator is used to calculate $\beta_1$ from the sample data provided by the survey. It provides an estimate of the impact of being married on happiness, calculated using:
  $$
  \hat{\beta}_1 = \frac{\sum_{i=1}^n (X_i - \bar{X})(Y_i - \bar{Y})}{\sum_{i=1}^n (X_i - \bar{X})^2}
  $$
  where $X_i$ is a binary indicator for being married (1 for married, 0 for not married), $Y_i$ is the observed happiness score, and $\bar{X}$, $\bar{Y}$ are the sample means of $X$ and $Y$, respectively.


(Note: you will not need to know this equation for the quiz)


The upshot, we anchor our causal inquiries within a mult-step framework of data analysis. This involves: 

1. clearly defining our causal estimand within a specified *target population,*
2. clarifying assumptions, & especially identification assumptions, 
3. describing a statistical strategy for extracting this estimand from the data, and then 
4. applying an algorithm that embodies this statistical method.


## Methods for Statistical Estimation in Causal Inference: Inverse Probability of Treatment Weights Using Propensity Scores

Last week, we discussed confounding control using regression adjustment. Recall the formula for the average treatment effect (ATE) when conditioning on a set of covariates $L$:

$$
\begin{aligned}
\text{ATE} = E[Y^{a=1} \mid L = l] - E[Y^{a=0} \mid L = l] \quad \text{for any value of } l
\end{aligned}
$$

> "We say that a set $L$ of measured non-descendants of $L$ is a sufficient set for confounding adjustment when conditioning on $L$ blocks all backdoor paths—that is, the treated and the untreated are exchangeable within levels of $L$" (Hernán & Robins, *Causal Inference*, p. 86).

This formula calculates the expected outcome difference between treated ($a=1$) and untreated ($a=0$) groups, given a specific value of the covariates $l$.

Inverse Probability of Treatment Weighting (IPTW) takes a different approach. We create a pseudo-population where the treatment assignment is independent of the observed covariates by assigning weights to each individual based on their propensity scores.

**We do this by modelling the treatment**

Denote the treatment indicator by $A$, where $A = 1$ if an individual receives treatment and $A = 0$ otherwise. $L$ represents the vector of observed covariates, and $Y^a$ the potential outcomes. The propensity score, $e(L)$, is defined as the probability of receiving the treatment given the observed covariates:

$$
\hat{e}(L) = P(A = 1 \mid L)
$$

To obtain IPTW weights, compute the inverse probability of treatment:

$$
v_i = \frac{A_i}{\hat{e}(L_i)} + \frac{1 - A_i}{1 - \hat{e}(L_i)}
$$

Which simplifies to 

$$
v_i = 
\begin{cases} 
\frac{1}{\hat{e}} & \text{if } A_i = 1 \\
\frac{1}{1-\hat{e}} & \text{if } A_i = 0 
\end{cases}
$$

where $v_i$ is the IPTW weight for individual $i$, $A_i$ is the treatment indicator for individual $i$, and $\hat{e}(L_i)$ is the estimated propensity score for individual $i$.   

How might we use these weights to obtain causal effect estimates?



## Marginal Structural Models (MSMs)

Marginal Structural Models (MSMs) estimate causal effects without requiring an "outcome model" that stratifies on covariates. Rather, MSMs employ weights derived from the inverse probability of treatment weighting (IPTW) to create a pseudo-population in which the distribution of covariates is independent of treatment assignment over time.

The general form of an MSM can be expressed as follows:

$$
E[Y^a] = \beta_0 + \beta_1a
$$

where $E[Y^a]$ is the expected outcome under treatment $a$  and $\beta_0$ and $\beta_1$ are parameters estimated by fitting the weighted model. Again, the weights used in the MSM, typically derived from the IPTW (or another treatment model), adjust for the confounding, allowing the model to estimate the unbiased effect of the treatment on the outcome without requiring covariates in the model.

Where do weights fit in?   Note, we have $E[Y^a]$ in please of $E[Y|A=a]$.  When applying propensity score weights in the linear regression model $E[Y^a] = \beta_0 + \beta_1a$, each observation is weighted by $v_i$, such that $v_i(\beta_0 + \beta_1a)$. This changes the estimation process to focus on a weighted sum of outcomes, where each individual's contribution is adjusted to reflect their probability of receiving the treatment, given their covariates.


## Interpretation of $\beta_0$ and $\beta_1$  in a Marginal Structural Model

### Binary Treatment

In models where the treatment $a$ is binary (e.g., $a = 0$ or $a = 1$), such as in many causal inference studies:

- **$\beta_0$**: the expected value of the outcome $Y$ when the treatment is not applied ($a = 0$). This is the baseline level of the outcome in the absence of treatment.
- **$\beta_1$**: the change in the expected outcome when the treatment status changes from 0 to 1. In logistic regression, $\beta_1$ represents the log-odds ratio of the outcome for the treatment group relative to the control group. In linear regression, $\beta_1$ quantifies the difference in the average outcome between the treated and untreated groups.

### Continuous Treatment

When the treatment $a$ is continuous, the interpretation of $\beta_0$ and $\beta_1$ adjusts slightly:

- **$\beta_0$**: represents the expected value of the outcome $Y$ when the treatment $a$ is at its reference value (often zero). 
- **$\beta_1$**: represents the expected change in the outcome for each unit increase in the treatment. In this case, $\beta_1$ measures the gradient or slope of the relationship between the treatment and the outcome. For every one-unit increase in treatment, the outcome changes by $\beta_1$ units, assuming all other factors remain constant.


<!-- ### Example: Binary treatment, Binary outcome -->

<!-- ### Logistic Regression Model -->

<!-- In the logistic regression (binary outcomes), the Marginal Structural Model (MSM) model is specified as: -->
<!-- $$ -->
<!-- \text{Logit}(E[Y^a]) = \beta_0 + \beta_1 a, -->
<!-- $$ -->

<!-- where $a$ is the treatment indicator (0 for no treatment, 1 for treatment). -->

<!-- ### Calculation for$Y^{a=0}$(No Treatment) -->

<!-- - **Model Simplification**: when$a = 0$(no treatment), the logit model simplifies to: -->

<!--  $$ -->
<!--   \text{Logit}(E[Y^{a=0}]) = \beta_0. -->
<!--  $$ -->


<!-- - **Expected Outcome**: To find$E[Y^{a=0}]$, convert the logit back to probability: -->

<!--  $$ -->
<!--   E[Y^{a=0}] = \frac{e^{\beta_0}}{1 + e^{\beta_0}} -->
<!--  $$ -->

<!--   This formula gives the predicted probability of the outcome occurring when there is no treatment. -->

<!-- ### Calculation for$Y^{a=1}$(Treatment Given) -->

<!-- - **Model Specification**: when$a = 1$(treatment given), the logit model is: -->

<!--  $$ -->
<!--   \text{Logit}(E[Y^{a=1}]) = \beta_0 + \beta_1. -->
<!--  $$ -->

<!-- - **Expected Outcome**: To find$E[Y^{a=1}]$, similarly convert the logit to probability: -->

<!--  $$ -->
<!--   E[Y^{a=1}] = \frac{e^{\beta_0 + \beta_1}}{1 + e^{\beta_0 + \beta_1}}. -->
<!--  $$ -->

<!--   This is the predicted probability of the outcome occurring when the treatment is applied. -->

<!-- ### Example of MSM -->

<!-- Suppose$\beta_0 = -0.5$and$\beta_1 = 0.8$. Then: -->

<!-- - **No Treatment**:  -->

<!--  $$ -->
<!--   E[Y^{a=0}] = \frac{e^{-0.5}}{1 + e^{-0.5}} \approx \frac{0.607}{1.607} \approx 0.378, -->
<!--  $$ -->


<!-- indicating a 37.8% probability of the outcome occurring without treatment. -->

<!-- - **With Treatment**: -->
<!--  $$ -->
<!--   E[Y^{a=1}] = \frac{e^{-0.5 + 0.8}}{1 + e^{-0.5 + 0.8}} = \frac{e^{0.3}}{1 + e^{0.3}} \approx \frac{1.35}{2.35} \approx 0.574, -->
<!--  $$ -->

<!-- indicating a 57.4% probability of the outcome occurring with treatment. -->


###  How can we apply marginal structural models in subgroups? 


### Assumptions

- **Model assumptions**: the treatment model is correctly specified.
- **Causal assumptions**: all confounders are appropriately controlled, positivity and consistency assumptions hold.


### Calculating Treatment Weights (Propensity Scores) and Confounding Control in Subgroups

We may often achieve greater balance when conducting weighted analyses in subgroups by estimating propensity scores *within* these subgroups. The propensity score $ e(L, G) $ is the conditional probability of receiving the exposure $ A = 1 $, given the covariates $ L $ and subgroup indicator $ G $. This is often modelled using logistic regression or other methods that ensure covariate balance
We define the estimated propensity score as follows:

$$
\hat{e} = P(A = 1 \mid L, G) = f_A(L, G; \theta_A)
$$

Here, $ f_A(L, G; \theta_A) $ is the statistical model estimating the probability of exposure $A = 1$ given covariates $L$ and subgroup $G$. We then calculate the weights for each individual, denoted $v$, using the estimated propensity score:

$\theta_A$ encapsulates all the coefficients (parameters) in this model, including intercepts, slopes, and potentially other parameters depending on the model complexity (e.g., interaction terms, non-linear effects...etc).

These weights $v$ depend on $A$ and are calculated as the inverse of the propensity score for exposed individuals and as the inverse of $ 1-\hat{e} $ for unexposed individuals.

Propensity scores are estimated *separately* within strata of the subgroup to control for potential confounding tailored to each subgroup. These weights $v$ are specific to each individual in subgroup $G$. In the lab, we will clarify how to fit models to estimate contrasts for the causal effects within groups $\hat{\delta}_{g}, \hat{\delta}_{g'}$, etc., and how to obtain estimates for group-wise differences:

$$
\hat{\gamma} = \overbrace{\big( \hat{E}[Y^a \mid G=g] - \hat{E}[Y^{a'} \mid G=g] \big)}^{\hat{\delta}_g} - \overbrace{\big( \hat{E}[Y^{a'} \mid G=g'] - \hat{E}[Y^a \mid G=g'] \big)}^{\hat{\delta}_{g'}}
$$


- **$\hat{E}[Y^a \mid G=g]$**: Estimated expected outcome when treatment $a$ is applied to subgroup $G=g$.
- **$\hat{E}[Y^{a'} \mid G=g]$**: Estimated expected outcome when a different treatment or control $a'$ is applied to the same subgroup $G=g$.
- **$\hat{\delta}_g$**: Represents the estimated treatment effect within subgroup $G=g$, computed as the difference in expected outcomes between treatment $a$ and $a'$ within this subgroup.

- **$\hat{E}[Y^{a'} \mid G=g']$**: Estimated expected outcome when treatment $a'$ is applied to a different subgroup $G=g'$.
- **$\hat{E}[Y^a \mid G=g']$**: Estimated expected outcome when treatment $a$ is applied to subgroup $G=g'$.
- **$\hat{\delta}_{g'}$**: Represents the estimated treatment effect within subgroup $G=g'$, computed as the difference in expected outcomes between treatment $a'$ and $a$ within this subgroup.

- **$\hat{\gamma}$**: The overall measure calculated from your formula represents the difference in treatment effects between two subgroups, $G=g$ and $G=g'$. It quantifies how the effect of switching between treatments $a$ and $a'$ differs across the two subgroups.


### Considerations

- **Estimation**: to estimate the expected outcomes $\hat{E}[Y^a \mid G]$ and $\hat{E}[Y^{a'} \mid G]$, we require statistical models. If we use regression, we include interaction terms between treatment and subgroup indicators to directly estimate subgroup-specific treatment effects. Our use depends on correct model specification.
- **Confidence intervals**: we may compute confidence intervals for $\hat{\gamma}$ using bootstrap, the delta method, or -- in our excercises -- simulation based methods.
- **Causal assumptions**: again, a causal interpretation of $\hat{\gamma}$ relies on satisfying both causal assumptions and modelling assumptions.  Here, we have described estimation using propensity scores.


## Doubly Robust Estimation

We can combine regression-based estimation with propensity score estimation to obtain *doubly robust* estimation. I will walk you through the steps in the lab. The TL;DR is this: doubly robust estimation reduces reliance on correct model specification. If either the PS model or the regression model is correctly specified, the model will be unbiased -- if the other causal inference assumptions are met.

We cannot know whether these assumptions are met, we will need to do a sensitivity analysis, the topic of next week.

I'll show you in lab how to employ simulation-based inference methods to compute standard errors and confidence intervals, following the approaches suggested by Greifer (2023)[].

## Readings:

Noah Griefer's Software and Blogs: [https://ngreifer.github.io/blog/subgroup-analysis-psm/](https://ngreifer.github.io/blog/)


# Lab


Today we estimate causal effects

```{r}

# uncomment, update the margot package
# devtools::install_github("go-bayes/margot")

# load packages
library(tidyverse)
library(margot)
library(skimr)
library(naniar)
library(WeightIt)
library(clarify)
library(MatchThem)
library(cobalt)
library(MatchIt)
library(kableExtra)
library(lmtp)
library(SuperLearner)
library(ranger)
library(nnls)
library(polspline)

# create a folder names saved (you should have done this last week).
# set your path to this folder

# save in cloud if using github
push_mods <- here::here('/Users/joseph/Library/CloudStorage/Dropbox-v-project/data/saved')

# check it is correct
# uncomment, check
#push_mods

# set seed for reproducability
set.seed(123)


# eliminate haven labels
df_nz <- as.data.frame(df_nz)
df_nz <- haven::zap_formats(df_nz)
df_nz <- haven::zap_label(df_nz)
df_nz <- haven::zap_widths(df_nz)

# read functions
# source("/Users/joseph/GIT/templates/functions/funs.R")

# experimental functions (more functions)
# source(
#   "https://raw.githubusercontent.com/go-bayes/templates/main/functions/experimental_funs.R"
# )
# # set exposure name

name_exposure <-  "perfectionism"

# check missing values
skimr::skim(df_nz) |> arrange(n_missing)

# obtain ids for individuals who participated in 2018 and have no missing baseline exposure
ids_2018 <- df_nz |>
  dplyr::filter(year_measured == 1, wave == 2018) |>
  dplyr::filter(!is.na(!!sym(name_exposure))) |> # criteria, no missing
  dplyr::filter(!is.na(eth_cat)) |> # criteria, no missing
  pull(id)


# obtain ids for individuals who participated in 2019
ids_2019 <- df_nz |>
  dplyr::filter(year_measured == 1, wave == 2019) |>
  dplyr::filter(!is.na(!!sym(name_exposure))) |> # criteria, no missing
  pull(id)

# intersect IDs from 2018 and 2019 to ensure participation in both years
ids_2018_2019 <- intersect(ids_2018, ids_2019)

# data wrangling
dat_long <- df_nz |>
  dplyr::filter(id %in% ids_2018_2019 &
                  wave %in% c(2018, 2019, 2020)) |>
  arrange(id, wave) |>
  select(
    "id",
    "wave",
    "year_measured",
    "age",
    "male",
    "born_nz",
    "eth_cat",
    #factor(EthCat, labels = c("Euro", "Maori", "Pacific", "Asian")),
    "employed",
    # are you currently employed? (this includes self-employment or casual work)
    "edu",
    # "gen_cohort",
    "household_inc",
    "partner",
    # 0 = no, 1 = yes
    "parent",
    "alert_level_combined_lead", # see bibliography
    # 0 = no, 1 = yes
    "political_conservative", # see nzavs sheet
    "hours_exercise", # see nzavs sheet
    "agreeableness", 
    # Mini-IPIP6 Agreeableness (also modelled as empathy facet)
    # Sympathize with others' feelings.
    # Am not interested in other people's problems.
    # Feel others' emotions.
    # Am not really interested in others.
    "conscientiousness",
    # see mini ipip6
    # Get chores done right away.
    # Like order.
    # Make a mess of things.
    # Often forget to put things back in their proper place.
    "extraversion",
    # Mini-IPIP6 Extraversion
    # Am the life of the party.
    # Don't talk a lot.
    # Keep in the background.
    # Talk to a lot of different people at parties.
    "honesty_humility",
    # see mini ipip6
    # Would like to be seen driving around in a very expensive car.
    # Would get a lot of pleasure from owning expensive luxury goods.
    # Feel entitled to more of everything.
    # Deserve more things in life.
    "openness",
    # see mini ipip6
    # Have a vivid imagination.
    # Have difficulty understanding abstract ideas.
    # Do not have a good imagination.
    # Am not interested in abstract ideas.
    "neuroticism",
    # see mini ipip6
    # Have frequent mood swings.
    # Am relaxed most of the time.
    # Get upset easily.
    # Seldom feel blue.
    "modesty",
    # # see mini ipip6
    # # I want people to know that I am an important person of high status,
    # # I am an ordinary person who is no better than others.
    # # I wouldn’t want people to treat me as though I were superior to them.
    # # I think that I am entitled to more respect than the average person is
    #"w_gend_age_ethnic",
    "neighbourhood_community",
    # #I feel a sense of community with others in my local neighbourhood.
    "belong", # see nzavs sheet
    "rural_gch_2018_l",# see nzavs sheet
    "support",
    # "support_help",
    # # 'There are people I can depend on to help me if I really need it.
    # "support_turnto",
    # # There is no one I can turn to for guidance in times of stress.
    # "support_rnoguidance",
    #There is no one I can turn to for guidance in times of stress.
    "perfectionism",
    "religion_religious",
    "kessler_latent_depression",
    "kessler_latent_anxiety"
  ) |>
  mutate(
    #initialize 'censored'
    censored = ifelse(lead(year_measured) == 1, 1, 0),
    
    # modify 'censored' based on the condition; no need to check for NA here as 'censored' is already defined in the previous step
    censored =  ifelse(is.na(censored) &
                         year_measured == 1, 1, censored),
    # create urban binary variable
    
    urban = ifelse(rural_gch_2018_l == 1, 1, 0)
    
  ) |>
  select(-c(year_measured, rural_gch_2018_l) )|>
  dplyr::mutate(
    # rescale these variables, to get all variables on a similar scale
    # otherwise your models can blow up, or become uninterpretable. 
    household_inc_log = log(household_inc + 1),
    hours_exercise_log = log(hours_exercise + 1)  ) |>
  dplyr::select(
    -c(
      household_inc,
      hours_exercise)
  ) |>
  droplevels() |>
  # dplyr::rename(sample_weights = w_gend_age_ethnic,
  #               sample_origin =  sample_origin_names_combined) |>
  arrange(id, wave) |>
  mutate(
    urban = as.numeric(as.character(urban)),
    #   parent = as.numeric(as.character(parent)),
    partner = as.numeric(as.character(partner)),
    born_nz = as.numeric(as.character(born_nz)),
    censored = as.numeric(as.character(censored)),
    employed = as.numeric(as.character(employed))
  ) |>
  droplevels() |>
  arrange(id, wave) |>
  data.frame()


# inspect data
glimpse(dat_long)

# more thorough view
#skimr::skim(dat_long)
```


Next let's insure that we obtain 50/50 representation of gender within our estimation.  


```{r}
# balance on gender weights
# calculate gender weights assuming male is coded as 1 and female as 0
prop_male_population <-
  0.5  # target proportion of males in the population
prop_female_population <-
  0.5  # target proportion of females in the population

prop_male_sample <- mean(dat_long$male)
prop_female_sample <- 1 - prop_male_sample

gender_weight_male <- prop_male_population / prop_male_sample
gender_weight_female <- prop_female_population / prop_female_sample

dat_long$sample_weights <-
  ifelse(dat_long$male == 1, gender_weight_male, gender_weight_female)

# we will upweight males and down weight non-males to obtain a balance of gender in the *target* population
table(dat_long$sample_weights)
```
Next let's get our data into shape.  Today we're going to consider a 'treatment' of perfectionism in which we shift people by different quantiles of perfectionism: 




```{r}
dat_long <-
  margot::create_ordered_variable(dat_long, "perfectionism", n_divisions = 4) #

# view scale
# uncommentto see break points
# print(quantile(dat_long$perfectionism, probs = seq(0, 1, 1/4), na.rm = TRUE))

# n by groups
table(dat_long$perfectionism_4tile)

# obtain labels if useful later
labels <- levels(dat_long$perfectionism_4tile)
```




### Consider where the quantiles break

```{r}
#| fig-width: 12
#| fig-height: 12


dt_19 <- dat_long |> filter(wave == 2019)

margot::coloured_histogram_quantiles(col_name = "perfectionism",
                                     n_quantiles = 4,
                                     binwidth = .5,
                                     dt_19)
```


### Consider mean

```{r}
#| fig-width: 12
#| fig-height: 12


dt_19 <- dat_long |> filter(wave == 2019)

margot::coloured_histogram_sd(col_name = "perfectionism", binwidth = .5, dt_19)

margot::coloured_histogram_shift(col_name = "perfectionism", binwidth = .1, 
                                 shift = "down",
                                 range_highlight = c(1,2),
                                 dt_19)
```



### Set variables

Next lets set our baseline variables

```{r}
baseline_vars = c("age", "male", "edu", "eth_cat", "partner", "employed", "born_nz", "neighbourhood_community", "household_inc_log", "parent", "religion_religious", "urban", "employed", "alert_level_combined_lead", "sample_weights")

# treatment
exposure_vars = c("perfectionism_4tile") 

# outcome, can be many
outcome_vars = c("kessler_latent_anxiety", "kessler_latent_depression")
```




### Muliply impute missing values


In our first analysis we will not merely impute baseline values. Rather we will impute baseline and outcome values within quantiles of the exposure.  Consider, why should we impute within the treatments to be compared?  What are the lingering dangers of this approach? 




```{r}
# make long data wide
prep_dat_wide <- margot_wide(dat_long, 
                             baseline_vars = baseline_vars, 
                             exposure_var = exposure_vars,
                             outcome_vars = outcome_vars)


# filter data, so that we impute within quartiles
list_filtered_df <-
  margot::margot_filter(prep_dat_wide, exposure_vars = "t1_perfectionism_4tile", sort_var = "id")

# check that these add up to the total data set
a <- nrow( list_filtered_df$tile_1)
b <- nrow( list_filtered_df$tile_2)
c <- nrow( list_filtered_df$tile_3)
d <-nrow( list_filtered_df$tile_4)

# must sum to equal
a + b + c + d == nrow(prep_dat_wide)
```


#### Visualise missing values

```{r}
# visually inspect missingness
naniar::vis_miss(prep_dat_wide, warn_large_data = FALSE)

# check for collinear vars
mice:::find.collinear(prep_dat_wide)
```


#### Imputations
Next we impute by quartile.  Save this output in your folder. 

```{r}
#| label: imputation
#| eval: false
#| include: true
#| echo: true

# impute by quartile
mice_health <- margot::impute_and_combine(list_filtered_df,  m = 5 )

margot::here_save(mice_health, "mice_health")
```


### Wrangling

```{r}
#| label: read-imputation
#| eval: false
#| echo: true

# read data if you are not running the imputation again
mice_health <- here_read("mice_health")

# post-imputation arrange
mice_health_mids <- mice_health |>
  arrange(.imp, id) |>
  rename(sample_weights = t0_sample_weights) |>
dplyr::mutate(
  across(
    where(is.numeric) & !t0_alert_level_combined_lead &
      !sample_weights,
    ~ scale(.x),
    .names = "{col}_z"
  )
) |>
  select(-.imp_z, -.id_z) |>
  select(where(is.factor),
         sample_weights,
         ends_with("_z"),
         .imp,
         .id) |>
  relocate(sample_weights, .before = starts_with("t1_"))  |>
  relocate(id, .before = sample_weights)  |>
  relocate(starts_with("t0_"), .before = starts_with("t1_"))  |>
  relocate(starts_with("t2_"), .after = starts_with("t1_"))  |>
  arrange(.imp, id) |>
  droplevels() |>
  mutate_if(is.matrix, as.vector) |>
  as.mids()

# this is how you save without the margot package
saveRDS(mice_health_mids, here::here("saved", "mice_health_mids"))
saveRDS(mice_health_long, here::here("saved", "mice_health_long"))
```

### Compute propensity scores for IPTW


```{r}
#| label: propensity-scores
#| eval: false
#| echo: true

# this is how you read saved files without the margot package
mice_health_mids <- readRDS(here::here(push_mods, "mice_health_mids"))
mice_health_long <- readRDS(here::here(push_mods, "mice_health_long"))
# propensity scors --------------------------------------------------------


# set exposure
X = "t1_perfectionism_4tile"

# set estimand
estimand = "ATE"

# set baseline varaibles
baseline_vars_models = mice_health_long |>
  dplyr::select(starts_with("t0"))|> colnames() # note, we earlier change name of `t0_sample_weights` to `sample weights`

baseline_vars_models
# obtain propensity scores
match_ebal_ate <- margot::match_mi_general(data = mice_health_mids, 
                                      X = X, 
                                      baseline_vars = baseline_vars_models, 
                                      estimand = "ATE",  
                                   #   focal = "tile_3", #for ATT
                                      method = "ebal", 
                                      sample_weights = "sample_weights")

# save output
margot::here_save(match_ebal_ate, "match_ebal_ate")
```


```{r}
#| label: vis_matching_ate
#| eval: true
#| echo: true
#| fig-width: 12
#| fig-height: 12

# read output
match_ebal_ate <- margot::here_read("match_ebal_ate")


# check balance
#bal.tab(match_ebal_ate)

# visualise imbalance
love.plot(match_ebal_ate, binary = "std", thresholds = c(m = .1),
          wrap = 50, position = "bottom", size =3)
```


```{r}
# consider results 
sum_ebal_match_ebal_ate <- summary(match_ebal_ate)

# summarise
sum_ebal_match_ebal_ate

# visualise
plot(sum_ebal_match_ebal_ate)

```

Some extreme weights.  We can trip weights as follows. (Note there is no hard and fast rule about how much to trim weights by.)

```{r}
#| fig-width: 12
#| fig-height: 12

# trimmed weights
match_ebal_ate_trim <- WeightIt::trim(match_ebal_ate, at = .99)

# check balance
# bal.tab(match_ebal_ate_trim)

# summary
summary_match_ebal_ate_trim <- summary(match_ebal_ate_trim)

# check - extreme weights gone
plot(summary_match_ebal_ate_trim)

# plot for balance
love.plot(match_ebal_ate_trim, binary = "std", thresholds = c(m = .1),
          wrap = 50, position = "bottom", size =2, limits = list(m = c(-.5, .5)))
```

### Estimation

```{r}
#| label: estimate
#| eval: false
#| echo: true
# here_save(match_ebal_ate_trim, "match_ebal_ate_trim")
# match_ebal_ate_trim <- here_read( "match_ebal_ate_trim")


# set data frame; output of match_mi_general model
df_ate = match_ebal_ate_trim

# remind self of levels if needed
# levels(mice_health_long$t1_perfectionism_4tile)

# set treatment level
treat_0 = "tile_1" # lowest quartile
treat_1 = "tile_3" # third quartile

# bootstrap simulations ( generally use 1000)
nsims <- 1000

# cores
cl =  parallel::detectCores () 

estimand = "ATE"

# as specified
vcov = "HC2" # robust standard errors. 

# cores
cores = parallel::detectCores () # use all course

# Example call to the function


# propensity score only model
propensity_mod_fit_t2_kessler_latent_anxiety_z <-margot::double_robust_marginal(
  df = df_ate,
  Y = "t2_kessler_latent_anxiety_z",
  X = X, 
  baseline_vars = 1, # we are not regressing with any covariates
  treat_1 = treat_1,
  treat_0 = treat_0,
  nsims = 1000,
  cores = cores,
  family = "gaussian",
  weights = TRUE,
  continuous_X = FALSE,
  splines = FALSE,
  estimand = "ATE",
  type_causal = "RD",  
  type_tab = "RD",    
  vcov = vcov,         
  new_name = "Kessler Anxiety (PR)",
  delta = 1,
  sd = 1
)

# save
here_save(propensity_mod_fit_t2_kessler_latent_anxiety_z, "propensity_mod_fit_t2_kessler_latent_anxiety_z")

propensity_mod_fit_t2_kessler_latent_depression_z <-margot::double_robust_marginal(
  df = df_ate,
  Y = "t2_kessler_latent_depression_z",
  X = X,  
  baseline_vars = 1, #no covariates, only the propensity scores
  treat_1 = treat_1,
  treat_0 = treat_0,
  nsims = 1000,
  cores = cores,
  family = "gaussian",
  weights = TRUE,
  continuous_X = FALSE,
  splines = FALSE,
  estimand = "ATE",
  type_causal = "RD",  
  type_tab = "RD",    
  vcov = vcov,         
  new_name = "Kessler Depression (PR)",
  delta = 1,
  sd = 1
)

# save
here_save(propensity_mod_fit_t2_kessler_latent_depression_z, "propensity_mod_fit_t2_kessler_latent_depression_z")



## Doubly robust
mod_fit_t2_kessler_latent_anxiety_z <-margot::double_robust_marginal(
  df = df_ate,
  Y = "t2_kessler_latent_anxiety_z",
  X = X,
  baseline_vars = baseline_vars_models, # no covariates, only the propensity scores
  treat_1 = treat_1,
  treat_0 = treat_0,
  nsims = 1000,
  cores = cores,
  family = "gaussian",
  weights = TRUE,
  continuous_X = FALSE,
  splines = FALSE,
  estimand = "ATE",
  type_causal = "RD",  
  type_tab = "RD",    
  vcov = vcov,         
  new_name = "Kessler Anxiety (DR)",
  delta = 1,
  sd = 1
)

# save
here_save(propensity_mod_fit_t2_kessler_latent_anxiety_z, "propensity_mod_fit_t2_kessler_latent_anxiety_z")


# model 2
mod_fit_t2_kessler_latent_depression_z <-margot::double_robust_marginal(
  df = df_ate,
  Y = "t2_kessler_latent_depression_z",
  X = X,
  baseline_vars = baseline_vars_models,
  treat_1 = treat_1,
  treat_0 = treat_0,
  nsims = 1000,
  cores = cores,
  family = "gaussian",
  weights = TRUE,
  continuous_X = FALSE,
  splines = FALSE,
  estimand = "ATE",
  type_causal = "RD",  
  type_tab = "RD",    
  vcov = vcov,         
  new_name = "Kessler Depression (DR)",
  delta = 1,
  sd = 1
)

# save
here_save(mod_fit_t2_kessler_latent_depression_z, "mod_fit_t2_kessler_latent_depression_z")
```


### Results

```{r}
#| eval: false
#| echo: true
# to save time, we do not run the models
# recover saved models 

# propensity score  models
propensity_mod_fit_t2_kessler_latent_depression_z<- here_read("propensity_mod_fit_t2_kessler_latent_depression_z")
propensity_mod_fit_t2_kessler_latent_anxiety_z<- here_read("propensity_mod_fit_t2_kessler_latent_anxiety_z")

# doubly robust models
mod_fit_t2_kessler_latent_depression_z<- here_read("mod_fit_t2_kessler_latent_depression_z")
mod_fit_t2_kessler_latent_anxiety_z<- here_read("mod_fit_t2_kessler_latent_anxiety_z")


# tables
library(kableExtra)

# proprensity only 
tab_double_pr <- rbind(propensity_mod_fit_t2_kessler_latent_depression_z$tab_results,
      propensity_mod_fit_t2_kessler_latent_anxiety_z$tab_results)
# bind results in a table
tab_double_robust <- rbind(mod_fit_t2_kessler_latent_depression_z$tab_results,
      mod_fit_t2_kessler_latent_anxiety_z$tab_results)


# combine the individual results
tab_combo <- rbind(tab_double_pr,tab_double_robust)


# table
tab_combo |> 
  kbl(format = "markdown")
```


We see that the doubly robust estimator leads to lower overall effect sizes



### Subgroup estimation 

```{r}
#| label: impute_subgroup_baseline
# let's take a different approach
# this time we include the censored variable 

exposure_vars <- c("perfectionism_4tile", "censored")
baseline_vars<-setdiff(baseline_vars, "sample_weights")

# here we imput the baseline 
df_impute_base<- margot_wide_impute_baseline(dat_long, baseline_vars = baseline_vars, 
                                             exposure_var = exposure_vars, outcome_vars = outcome_vars)

# save

# get sample weights
dt_18 <- dat_long |> filter(wave == 2018)

# add sample weights
df_impute_base$t0_sample_weights = dt_18$sample_weights

# save
here_save(df_impute_base, "df_impute_base")
```

### Wrangling


```{r}
df_impute_base <- here_read("df_impute_base")

# get correct censoring 
t0_na_condition <-
  rowSums(is.na(select(df_impute_base, starts_with("t1_")))) > 0
t1_na_condition <-
  rowSums(is.na(select(df_impute_base, starts_with("t2_")))) > 0

# tidy your data
df_clean <- df_impute_base |>
  mutate(t0_censored = ifelse(t0_na_condition, 0, t0_censored)) |>
  mutate(t1_censored = ifelse(t1_na_condition, 0, t1_censored))|>
  mutate(across(starts_with("t1_"), ~ ifelse(t0_censored == 0, NA_real_, .)),
         across(starts_with("t2_"), ~ ifelse(t0_censored == 0, NA_real_, .))) |>
  mutate(across(starts_with("t2_"), ~ ifelse(t1_censored == 0, NA_real_, .))) |>
  # select variables
  dplyr::mutate(
    across(
      .cols = where(is.numeric) &
        !t0_censored &
        !t0_sample_weights & 
        !t0_alert_level_combined_lead &
        !t1_perfectionism_4tile &
        !t1_censored,
      .fns = ~ scale(.),
      .names = "{.col}_z"
    )
  ) |>
  # select(-t0_charity_donate,
  #        -t0_hours_charity) |>
  select(
    where(is.factor),
    t0_sample_weights,
    t0_alert_level_combined_lead,
    t0_sample_weights,
    t0_censored,
    t1_perfectionism_4tile,
    t1_censored,
    ends_with("_z")
  ) |>
  mutate(t0_lost = 1 - t1_censored) |> 
  mutate(t1_lost = 1 - t1_censored) |> 
  mutate(t1_perfectionism_4tile = factor(t1_perfectionism_4tile, ordered = TRUE, labels = c("tile_1", "tile_2", "tile_3", "tile_4")) )|> 
  relocate(starts_with("t0_"), .before = starts_with("t1_")) |> # make a factor
  relocate("t0_censored", .before = starts_with("t1_"))  |>
  relocate("t1_censored", .before = starts_with("t2_")) 



# we'll have a variable for "lost" 
# this is the usual meaning of "censored"
table(df_clean$t1_lost)
table(df_clean$t1_censored)
str(df_clean$t1_perfectionism_4tile)


# 
# df_impute_base$t1_perfectionism_z = scale(df_impute_base$t1_perfectionism)

# get rid of attributes
df_clean <- margot::remove_numeric_attributes(df_clean)


# censoring ---------------------------------------------------------------
baseline_vars_models = df_clean |>  # post process of impute and combine
  dplyr::select(starts_with("t0"), - t0_alert_level_combined_lead,-t0_censored, -t0_lost, -t0_sample_weights)|> colnames() # note, we ear

baseline_vars_models
# fit proponsity score model 
match_censoring <- margot::match_mi_general(data = df_clean, 
                                      X = "t1_lost", 
                                      baseline_vars = baseline_vars_models, 
                                      estimand = "ATE",  
                                      # focal = "< >", for ATT
                                      method = "cbps", 
                                      sample_weights = "sample_weights")

# save output
here_save( match_censoring, "match_censoring") 
```
### Matching

```{r}
#| label: vis_matching_censoring
#| eval: true
#| echo: true
#| fig-width: 12
#| fig-height: 12

# read output
match_censoring <- margot::here_read("match_censoring")
# check balance
# bal.tab(match_censoring)

# visualise imbalance
love.plot(match_censoring, binary = "std", thresholds = c(m = .1),
          wrap = 50, position = "bottom", size =3)
```

### Subgroup analysis 

```{r}
#| label: subgroup_weights
#| eval: false
#| echo: true

# get censoring weights
lost_prob <- match_censoring$weights

# check
summary(lost_prob)

# rename sample weights # multiply censoring weights by sample weights 
df_clean$sample_weights <- (match_censoring$weights * df_clean$t0_sample_weights)

summary(df_clean$sample_weights )

# next filter only those who were not lost
df_clean_filtered<- df_clean |> 
  filter(t1_censored == 1)

df_clean_filtered <- df_clean_filtered |>
  relocate("sample_weights", .before = starts_with("t0_")) |>
  relocate(starts_with("t0_"), .before = starts_with("t1_")) |>
  relocate("t0_censored", .before = starts_with("t1_"))  |>
  relocate("t1_censored", .before = starts_with("t2_"))


nrow(df_clean_filtered)

hist(df_clean_filtered$sample_weights)

# next propensity scores by groups 

levels(df_clean_filtered$t0_eth_cat)
levels(df_clean_filtered$t1_perfectionism_4tile)
# 

df_subgroup <-df_clean_filtered |> filter(t0_eth_cat == "maori" | t0_eth_cat == "euro") |> droplevels()

# save
here_save(df_subgroup, "df_subgroup")

# check
table(df_subgroup$t0_eth_cat)

baseline_vars_models_sans_eth <- setdiff(baseline_vars_models, "t0_eth_cat")

# save
here_save(baseline_vars_models_sans_eth, "baseline_vars_models_sans_eth")

## 
string <- formula_str <- as.formula(paste("t1_perfectionism_4tile", "~", paste(baseline_vars_models, collapse = "+")))

string_sans <- formula_str <- as.formula(paste("t1_perfectionism_4tile", "~", paste(baseline_vars_models_sans_eth, collapse = "+")))

W1 <- weightit(
  string,
  method = "ipt",
  estimand = "ATT",
  weights = "sample_weights",
  focal = "tile_3",
  # super = TRUE,
  #SL.library = c("SL.ranger", "SL.glmnet", "SL.polymars", "SL.xgboost"),
  #super = TRUE,
  data = df_subgroup
)
summary(W1)

# save model
here_save(W1, "W1")

W2 <- weightit(
  string_sans,
  method = "ipt",
  estimand = "ATT",
  weights = "sample_weights",
  by = "t0_eth_cat",
  weights = "sample_weights",
  focal = "tile_3",
#  super = TRUE,
#  SL.library = c("SL.ranger", "SL.glmnet", "SL.polymars", "SL.xgboost"),
  data = df_subgroup
)

summary(W2)

# save model
here_save(W2, "W2")

# test diff

#S <- sbps(W1, W2)
# warnings()
# S
```

### Wvaluate subgroup weighting model

```{r}
#| fig-width: 12
#| fig-height: 12

W1 <- here_read("W1")
W2 <- here_read("W2")

# read
df_subgroup <- margot::here_read("df_subgroup")

# bal.tab(W1, un = TRUE)
love.plot(W1, binary = "std", thresholds = c(m = .1),
          wrap = 50, position = "bottom", size =2)

# this method has better effective samples
#bal.tab(W1)


# this method has better balance
# bal.tab(W2, cluster = "t0_eth_cat")
# bal.tab(W1, cluster = "t0_eth_cat")
# graph by cluster
love.plot(W1,  cluster = "t0_eth_cat", binary = "std", thresholds = c(m = .1),
          wrap = 50, position = "bottom", size =2)
```


### Parametric estimation of subgroup model

```{r}
# prepare data

# read vars
baseline_vars_models_sans_eth <- margot::here_read("baseline_vars_models_sans_eth")

# make combo weights
df_subgroup$combo_weights = W2$weights * df_subgroup$t0_sample_weights


# set dataframe
df = df_subgroup

### SUBGROUP analysis
Y_anxiety = "t2_kessler_latent_anxiety_z"
Y_depression = "t2_kessler_latent_depression_z"

X = "t1_perfectionism_4tile"

treat_0 = "tile_1"
treat_1 = "tile_3"
estimand = "ATT"
scale = "RD"
nsims = 1000
family = "gaussian"
continuous_X = FALSE
splines = FALSE
cores = parallel::detectCores()
S = "t0_eth_cat"

# not we interact the subclass X treatment X covariates

formula_str_anxiety <-
  paste(
    Y_anxiety,
    "~",
    S,
    "*",
    "(",
    X ,
    "*",
    "(",
    paste(baseline_vars_models_sans_eth, collapse = "+"),
    ")",
    ")"
  )

formula_str_depression <-
  paste(
    Y_depression,
    "~",
    S,
    "*",
    "(",
    X ,
    "*",
    "(",
    paste(baseline_vars_models_sans_eth, collapse = "+"),
    ")",
    ")"
  )

formula_str_anxiety
formula_str_depression

# fit model
fit_all_all_anxiety  <- glm(
  as.formula(formula_str_anxiety),
  weights = combo_weights,
  # weights = if (!is.null(weight_var)) weight_var else NULL,
  family = family,
  data = df
)

#summary(fit_all_all_anxiety)

fit_all_all_depression  <- glm(
  as.formula(formula_str_depression),
  weights = combo_weights,
  # weights = if (!is.null(weight_var)) weight_var else NULL,
  family = family,
  data = df
)


# coefs <- coef(fit_all_all_anxiety)
# table(is.na(coefs))#     t0_eth_catmāori:t1_perfectionism_coarsen.Q:t0_gen_cohort.C

# #FALSE  TRUE
# 344     4
# 
# insight::get_varcov(fit_all_all_anxiety)
```

### Subgroup Results 

```{r}
#| label: sim_subgroup
#| eval: false
#| echo: true

# simulate coefficients
sim_model_all <- sim(fit_all_all_anxiety, n = nsims, vcov = "HC2")


# simulate effect as modified in europeans
sim_estimand_all <- sim_ame(
  sim_model_all,
  var = X,
  cl = cores,
  by = "t0_eth_cat",
  verbose = FALSE
)

# summary(sim_estimand_all)

# make table
sim_estimand_all_tab <-
  transform(sim_estimand_all, RD_euro = `E[Y(tile_3)|euro]` - `E[Y(tile_1)|euro]`,
            RD_maori =  `E[Y(tile_3)|maori]` - `E[Y(tile_1)|maori]`,
            gamma_hat = (`E[Y(tile_3)|euro]` - `E[Y(tile_1)|euro]`) - (`E[Y(tile_3)|maori]` - `E[Y(tile_1)|maori]`))

sim_estimand_all_tab
# save table
here_save(sim_estimand_all_tab, "sim_estimand_all_tab")
```

Summary of model

```{r}
# read table
sim_estimand_all_tab <- margot::here_read("sim_estimand_all_tab")

# print table
summary(sim_estimand_all_tab)
```


### Machine learning estimation: subgroups

```{r}
#| label: lmtp_subgroup
#| eval: false
#| echo: true

# lmtp
library("lmtp")

# set number of folds for ML here. use a minimum of 5 and a max of 10
SL_folds = 10

#this will allow you to track progress
progressr::handlers(global = TRUE)

# set seed for reproducing results
set.seed(0112358)

# set cores for estimation
library(future)
plan(multisession)
n_cores <- parallel::detectCores() - 2 # save two cores for other work while these models run

# min of 10
n_cores

# super learner libraries
# these are useful for high-dimensional data
sl_lib <- c("SL.glmnet",
            "SL.glm",
            "SL.ranger", # forests
            "SL.xgboost") # grandient boost


df_maori <-df_clean_filtered |> filter(t0_eth_cat == "maori") |> select( -t0_lost, -t1_lost) |> droplevels()
df_euro <-df_clean_filtered |> filter(t0_eth_cat == "euro") |> select( -t0_lost, -t1_lost) |> droplevels()
nrow(df_maori)
nrow(df_euro)

colnames(df_clean_filtered)

A<- "t1_perfectionism_4tile"

# note lmtp's unconventional use of "censored"
C <- c("t1_censored")

df_clean_filtered$sample_weights

names_base <-
  df_clean_filtered |> select(starts_with("t0"),
                     -t0_sample_weights, 
                     -t0_censored,
                     -t0_lost,
                     -t0_eth_cat) |> colnames()

C <- c("t1_censored")


shift_all_tile_3 <- function(data, trt) {
  ifelse(data[[trt]] != "tile_3", "tile_3",  data[[trt]])
}
glimpse(df_maori)


shift_all_tile_1 <- function(data, trt) {
  ifelse(data[[trt]] != "tile_1", "tile_1",  data[[trt]])
}

C

## no parametric estimation 
maori_tile_3_t2_kessler_latent_anxiety_z <- lmtp_tmle(
    data = df_maori,
    trt = A,
    baseline = names_base,
    outcome = "t2_kessler_latent_anxiety_z",
    cens = C,
    shift = shift_all_tile_3,
    mtp = TRUE,
    folds = 10,
    # trim = 0.99, # if needed
    # time_vary = NULL,
    outcome_type = "continuous",
    weights = df_maori$sample_weights,
    learners_trt = "SL.ranger",
    learners_outcome ="SL.ranger",
    parallel = n_cores
  )
maori_tile_3_t2_kessler_latent_anxiety_z
here_save(maori_tile_3_t2_kessler_latent_anxiety_z, "maori_tile_3_t2_kessler_latent_anxiety_z")


maori_tile_1_t2_kessler_latent_anxiety_z <- lmtp_tmle(
    data = df_maori,
    trt = A,
    baseline = names_base,
    outcome = "t2_kessler_latent_anxiety_z",
    cens = C,
    shift = shift_all_tile_1,
    mtp = TRUE,
    folds = 10,
    # trim = 0.99, # if needed
    # time_vary = NULL,
    outcome_type = "continuous",
    weights = df_maori$sample_weights,
    learners_trt = "SL.ranger",
    learners_outcome ="SL.ranger",
    parallel = n_cores
  )
maori_tile_1_t2_kessler_latent_anxiety_z
here_save(maori_tile_1_t2_kessler_latent_anxiety_z, "maori_tile_1_t2_kessler_latent_anxiety_z")

# higher anxiety 
maori_results <-lmtp_contrast(maori_tile_3_t2_kessler_latent_anxiety_z, ref = maori_tile_1_t2_kessler_latent_anxiety_z)

here_save(maori_results, "maori_results")

euro_tile_3_t2_kessler_latent_anxiety_z <- lmtp_tmle(
    data = df_euro,
    trt = A,
    baseline = names_base,
    outcome = "t2_kessler_latent_anxiety_z",
    cens = C,
    shift = shift_all_tile_3,
    mtp = TRUE,
    folds = 10,
    # trim = 0.99, # if needed
    # time_vary = NULL,
    outcome_type = "continuous",
    weights = df_euro$sample_weights,
    learners_trt = "SL.ranger",
    learners_outcome ="SL.ranger",
    parallel = n_cores
  )
euro_tile_3_t2_kessler_latent_anxiety_z
here_save(euro_tile_3_t2_kessler_latent_anxiety_z, "euro_tile_3_t2_kessler_latent_anxiety_z")


euro_tile_1_t2_kessler_latent_anxiety_z <- lmtp_tmle(
    data = df_euro,
    trt = A,
    baseline = names_base,
    outcome = "t2_kessler_latent_anxiety_z",
    cens = C,
    shift = shift_all_tile_1,
    mtp = TRUE,
    folds = 10,
    # trim = 0.99, # if needed
    # time_vary = NULL,
    outcome_type = "continuous",
    weights = df_euro$sample_weights,
    learners_trt = "SL.ranger",
    learners_outcome ="SL.ranger",
    parallel = n_cores
  )
euro_tile_1_t2_kessler_latent_anxiety_z
here_save(euro_tile_1_t2_kessler_latent_anxiety_z, "euro_tile_1_t2_kessler_latent_anxiety_z")


euro_results <- lmtp_contrast(euro_tile_3_t2_kessler_latent_anxiety_z, ref = euro_tile_1_t2_kessler_latent_anxiety_z)
here_save(euro_results, "euro_results")

```


### Machine learning results

No difference between groups. 

```{r}
euro_results <- margot::here_read("euro_results")
maori_results<- margot::here_read("maori_results")

euro_results
maori_results

g_hat_theta= euro_results$vals$theta - maori_results$vals$theta 
g_hat_theta # difference of means
euro_results$vals$std.error
# difference 
se_diff = sqrt( (euro_results$vals$std.error^2) + (maori_results$vals$std.error^2) )

diff_conf.low = g_hat_theta - (1.97 * se_diff)
diff_conf.high = g_hat_theta + (1.97 * se_diff)


g_hat_anxiety <- cbind.data.frame(g_hat_theta, se_diff, diff_conf.low, diff_conf.high)

# result
g_hat_anxiety
```


Note, however that the invevention increases anxiety for both groups equally


### Europeans results

```{r}
euro_results <- margot::here_read("euro_results")
round( euro_results$vals, 3)
```


### Maori results

```{r}
maori_results<- margot::here_read("maori_results")
round(maori_results$vals, 3)
```


### Graph results

```{r}
tab_euro_results <- margot::margot_lmtp_evalue(
  euro_results,
  scale = "RD",
  new_name = "Euro: 1_tile to 3_tile"
)



tab_maori_results <- margot::margot_lmtp_evalue(
  maori_results,
  scale = "RD",
  new_name = "Māori: 1_tile to 3_tile"
)

bind_results_anxiety <- rbind(tab_euro_results, tab_maori_results)

here_save(bind_results_anxiety, "bind_results_anxiety")

group_tab_anxiety <- margot::group_tab(bind_results_anxiety, type = "RD")
```


```{r}
#| fig-width: 10
#| fig-height: 12

# graph results
 margot_plot(
  group_tab_anxiety,
  type = "RD",
  title = "Perfectionism: shift all to 3_tile, contrast with 1_tile",
  subtitle = "Outcome = Anxiety",
  estimate_scale = 1,
  base_size = 18,
  text_size = 4.5,
  point_size = 3.5,
  title_size = 20,
  subtitle_size = 16,
  legend_text_size = 10,
  legend_title_size = 10,
  x_offset = -.5,
  x_lim_lo = -.5,
  x_lim_hi =  .5
)
```


Interpret Results


```{r}
margot_interpret_table(group_tab_anxiety, estimand = "ATT", causal_scale = "causal_difference")
```


## Take Home Message

Machine learning with cross validation recovers nearly identical estimates for the effect of a shift in perfectionism on anxiety among Māori and Europeans. 

Which results are correct?  We don't know. With more time, we would add more learners to the model, including parametric learners. 


Generally, I suggest using machine learning algorithms, because they can include parametric estimators. 




