---
title: "experiment_template.qmd"
format: 
  html:
    code-fold: true
    code-overflow: scroll
    html-math-method: katex
    warnings: false
    error: false
    messages: false
    highlight: kate
---

Today we will do an analysis, proceeding in a step-by-step way. 

Recall our checklist:

1. Stating the Question: Is my question clearly stated? If not, state it.
2. Relevance of the Question: Have I explained its importance? If not, explain.
3. Causality of the Question: Is my question causal? If not, refine your question.
4. Subgroup Analysis: Does my question involve a subgroup (e.g., cultural group)? If not, develop a subgroup analysis question.

## Questions 

Question 1. Does exercise affect anxiety/depression? 
  
Question 2: Do these effects vary among NZ Europeans and Māori? 


Are these questions clearly stated? No, they are vague: 

- How much exercise? 
- By which measures of depression? 
- When should the effects be observed?  

Recall we can help to clarify these questions by attempting to emulate an experiment. 

We shall use the measure of exercise in the NZAVS: hours of activity per week (we shall see, the question remains vague).

We will assess the 1-year effect on Kessler-6 depression after initiating a change in exercise (intention-to-treat).

We will investigate effect-modification by NZ European and Māori ethnic identification.



## Preliminaries: source functions, import data. 

We source our functions, load libraries, and important our (synthetic) data. 

```{r}
#| label: load_libraries
#| output: false 

# PSYCH 434: Example script for assessment 3 and 5.

# Before running this source code, make sure to update to the current version of R, and to update all existing packages.

# WARNING:  COMMENT THIS OUT. JB DOES THIS FOR WORKING WITHOUT WIFI
source("/Users/joseph/GIT/templates/functions/libs2.R")

# WARNING:  COMMENT THIS OUT. JB DOES THIS FOR WORKING WITHOUT WIFI
source("/Users/joseph/GIT/templates/functions/funs.R")

# WARNING:  COMMENT THIS OUT. JB DOES THIS FOR WORKING WITHOUT WIFI
source("/Users/joseph/GIT/templates/functions/experimental_funs.R")
############## ############## ############## ############## ############## ############## ############## ########
#########  ############## ############## IMPORT DATA ##############  ############## ############## ##############
############## ############## ############## ############## ############## ############## ############## ########


#  If you haven't already, you should have created a folder called "data", in your Rstudio project. If not, download this file, add it to your the folder called "data" in your Rstudio project. # "https://www.dropbox.com/s/vwqijg4ha17hbs1/nzavs_dat_synth_t10_t12?dl=0"

# A function we will use for our tables. 
tab_ate_subgroup_rd <- function(x,
                                new_name,
                                delta = 1,
                                sd = 1) {
  # Check if required packages are installed
  required_packages <- c("EValue", "dplyr")
  new_packages <-
    required_packages[!(required_packages %in% installed.packages()[, "Package"])]
  if (length(new_packages))
    stop("Missing packages: ", paste(new_packages, collapse = ", "))
  
  require(EValue)
  require(dplyr)
  
  # check if input data is a dataframe
  if (!is.data.frame(x))
    stop("Input x must be a dataframe")
  
  # Check if required columns are in the dataframe
  required_cols <- c("estimate", "lower_ci", "upper_ci")
  missing_cols <- required_cols[!(required_cols %in% colnames(x))]
  if (length(missing_cols) > 0)
    stop("Missing columns in dataframe: ",
         paste(missing_cols, collapse = ", "))
  
  # Check if lower_ci and upper_ci do not contain NA values
  if (any(is.na(x$lower_ci), is.na(x$upper_ci)))
    stop("Columns 'lower_ci' and 'upper_ci' should not contain NA values")
  
  x <- x %>%
    dplyr::mutate(across(where(is.numeric), round, digits = 3)) %>%
    dplyr::rename("E[Y(1)]-E[Y(0)]" = estimate)
  
  x$standard_error <- abs(x$lower_ci - x$upper_ci) / 3.92
  
  evalues_list <- lapply(seq_len(nrow(x)), function(i) {
    row_evalue <- EValue::evalues.OLS(
      x[i, "E[Y(1)]-E[Y(0)]"],
      se = x[i, "standard_error"],
      sd = sd,
      delta = delta,
      true = 0
    )
    # If E_value is NA, set it to 1
    if (is.na(row_evalue[2, "lower"])) {
      row_evalue[2, "lower"] <- 1
    }
    if (is.na(row_evalue[2, "upper"])) {
      row_evalue[2, "upper"] <- 1
    }
    data.frame(round(as.data.frame(row_evalue)[2,], 3)) # exclude the NA column
  })
  
  evalues_df <- do.call(rbind, evalues_list)
  colnames(evalues_df) <- c("E_Value", "E_Val_bound")
  
  tab_p <- cbind(x, evalues_df)
  
  tab <-
    tab_p |> select(c(
      "E[Y(1)]-E[Y(0)]",
      "lower_ci",
      "upper_ci",
      "E_Value",
      "E_Val_bound"
    ))
  
  return(tab)
}
```

```{r}
#| label: import data

# This will read the synthetic data into Rstudio.  Note that the arrow package allows us to have lower memory demands in the storage and retrieval of data.
nzavs_synth <-
  arrow::read_parquet(here::here("data", "nzavs_dat_synth_t10_t12"))

```



Next, we will inspect column names. 

Make sure to familiarise your self with the variable names [here](https://github.com/go-bayes/psych-434-2023/blob/main/data/readme.qmd)

It's a good idea to plot the data

```{r}
#| echo: false
#| label: colnames
#| eval: false
## use colnames to inspect the variables

colnames(nzavs_synth)

# more about the variables here: 
# https://github.com/go-bayes/psych-434-2023/blob/main/data/readme.qmd
```


### Data Wrangling.

Next, we'll get the data into shape.  

Consider the following causal questions: "Does exercise affect well-being?" "Do such effects, if they exist, differ by ethnicity?"

These questions are not precise.  What type of excercise?  How regularly must one exercise? For how long must one exercise? Which ethnicities shall we compare?  Why? 

It helpst to think like an experimentalist... (say more)

In this exampe, we'll do the following: 

1. Create a Kessler 6 average score
2. Create a Kessler 6 sum score 
3. Create a Kessler 6 binary score (Not Depressed vs. Moderately or Severely Depressed)
4. Create a log Exercise score
5. Create a coarsened Exercise score. 


Consider: the NZAVS asks participants the following question. During the past week, list "Hours spent exercising/physical activity."  The question is inherently unclear about what sort of physical activity someone is doing.  When participants respond to this question, what do they mean?  John considers anything that is not sleep to be physical activity. He returns a high number. Jane only counts aerobic exercise. For Jane, walking an hour to work and back doesn't count. 

Recall that an assumption of causal inference is consistency. (Say more ... then leave to the side.)


For now, let's create the indicators. 

```{r}
#| label: data_wrangling

# create sum score of kessler 6
dt_start <- nzavs_synth %>%
  arrange(id, wave) %>%
  rowwise() %>%
  mutate(kessler_6  = mean(
    sum(
    # Specify the Kessler scale items
    c(
      kessler_depressed,
      # During the last 30 days, how often did you feel so depressed that nothing could cheer you up?
      kessler_hopeless,
      # During the last 30 days, how often did you feel hopeless?
      kessler_nervous,
      # During the last 30 days, how often did you feel nervous?
      kessler_effort,
      # During the last 30 days, how often did you feel that everything was an effort?
      kessler_restless,
      # During the last 30 days, how often did you feel restless or fidgety ?
      kessler_worthless  # During the last 30 days, how often did you feel worthless?
    )))) |>
  mutate(kessler_6_sum = round(
    sum(c (kessler_depressed,
                   kessler_hopeless,
                   kessler_nervous,
                   kessler_effort,
                   kessler_restless,
                   kessler_worthless)),
    digits = 0
  )) |>  ungroup() |>
# Create a categorical variable 'kessler_6_coarsen' based on the sum of Kessler scale items
  mutate(
    kessler_6_coarsen = cut(
      kessler_6_sum,
      breaks = c(0, 5, 24),
       labels = c(
        "not_depressed",
        "mildly_to_severely_depressed"),
      include.lowest = TRUE,
      include.highest = TRUE,
      na.rm = TRUE,
      right = FALSE
    )
  ) |>
  # Transform 'hours_exercise' by applying the log function to compress its scale
  mutate(hours_exercise_log = log(hours_exercise + 1)) |> # Add 1 to avoid undefined log(0). Hours spent exercising/physical activity

  # Coarsen 'hours_exercise' into categories
  mutate(
    hours_exercise_coarsen = cut(
      hours_exercise,
      # Hours spent exercising/ physical activity
      breaks = c(-1, 3, 8, 200),
      labels = c(
        "inactive",
        "active",
        "very_active"      ),
      # Define thresholds for categories
      levels = c("(-1,2]", "(2,8]", "(8,200]"),
      ordered = TRUE
    )
  ) |>

  # Create a binary 'urban' variable based on the 'rural_gch2018' variable
  mutate(urban = factor(
    ifelse(
      rural_gch2018 == "medium_urban_accessibility" |
        # Define urban condition
        rural_gch2018 == "high_urban_accessibility",
      "urban",
      # Label 'urban' if condition is met
      "rural"  # Label 'rural' if condition is not met
    )
  ))

```


We next do some data checks.  I will leave you to do these in your own time. 

```{r}
#| eval: false

# do some checks
levels(dt_start$hours_exercise_coarsen)
table(dt_start$hours_exercise_coarsen)
max( dt_start$hours_exercise)
min( dt_start$hours_exercise)
# checks
table(is.na(dt_start$kessler_6_coarsen))
table(is.na(dt_start$hours_exercise_coarsen))

# justification for transforming exercise" has a very long tail
hist(dt_start$hours_exercise, breaks = 1000)
# consider only those cases below < or = to 20
hist(subset(dt_start, hours_exercise <= 20)$hours_exercise)


# inspect kessler 6
table(dt_start$kessler_6_coarsen)
table(dt_start$hours_exercise_coarsen)

hist( as.numeric(dt_start$kessler_6_coarsen) )
hist( as.numeric(dt_start$hours_exercise_coarsen))

```

### CFA for Kessler 6


We have learned how to do confirmatory factor analysis. Let's put this knowledge to use, and consider whether Kessler 6 is one variable.


The code below will:

* Load required packages. 
* Select the Kessler 6 items
* Check whether there is sufficient correlation among the variables to support factor analysis. 

```{r}
#| label: cfa_factor_structure

# Suppose we have reason to think Kessler 6 isn't one thing.
# Let's put our factor analysis skills to work
# Here we will use the paramters and see packages for R (part of the Easystats suite)

# for efa/cfa
if (!require(psych)) {
  install.packages("psych")
  library("psych")
}

# for reporting
if (!require(parameters)) {
  install.packages("parameters")
  library("parameters")
}

# for graphing
if (!require(see)) {
  install.packages("see")
  library("see")
}

# for graphing
if (!require(lavaan)) {
  install.packages("lavaan")
  library("lavaan")
}


# for graphing
if (!require(datawizard)) {
  install.packages("datawizard")
  library("datawizard")
}


# select the columns we need. 
dt_only_k6 <- dt_start |> select(kessler_depressed, kessler_effort,kessler_hopeless,
                                 kessler_worthless, kessler_nervous,
                                 kessler_restless)


# check factor structure
performance::check_factorstructure(dt_only_k6)

```


The code below will allow us to explore the factor structure, on the assumption of n = 3 factors. 

```{r}
#| label: efa_made_easy
# exploratory factor analysis
# explore a factor structure made of 3 latent variables
efa <- psych::fa(dt_only_k6, nfactors = 3) %>%
  model_parameters(sort = TRUE, threshold = "max")

efa
# This output presents the results of an exploratory factor analysis (EFA), a statistical method used to discover the underlying structure of a relatively large set of variables. It's often used when you don't have a specific hypothesis about what latent factors (unobservable variables) might be influencing the observed variables in your dataset.
#
# In this analysis, we've requested three factors (latent variables), and the table presents the loadings of each observed variable on each of these factors. The loadings can be interpreted as the correlations between the observed variables and the latent factors.
#
# Here's how to interpret the output:
#
#   The variables kessler_depressed, kessler_worthless, and kessler_hopeless load strongly on the first latent factor (MR1), and do not significantly load on the other two. This suggests that these three variables share some common underlying factor.
#
# The variable kessler_nervous loads exclusively on the second latent factor (MR2), suggesting it might represent a different latent construct.
#
# The variables kessler_restless and kessler_effort load on the third latent factor (MR3), which could represent yet another underlying construct.
#
# The "Complexity" column indicates the complexity of each item. Complexity 1 indicates that the item is influenced mostly by a single factor.
#
# The "Uniqueness" column represents the proportion of variance in each variable that is not explained by the factors. For example, the uniqueness of kessler_depressed is 0.33, which means that 33% of the variance in this variable is not accounted for by the three factors.
#
# Lastly, the total variance explained by the three latent factors is 66.05%, with MR1 explaining 35.14%, MR2 explaining 17.17%, and MR3 explaining 13.73%. This indicates that about two-thirds of the variance in the six observed variables can be explained by the three latent factors extracted in the analysis.
# fa -- there is no agreed method!
# method of agreement:
```


```{r}
#| label: plot_factors

n <- n_factors(dt_only_k6)

# # summary
# as.data.frame(n)

# plot of smmary
plot(n) + theme_modern()


## CFA
```

Next try a CFA


```{r}
#| label: cfa


# first partition the data 
part_data <- datawizard::data_partition(dt_only_k6, traing_proportion = .07, seed = 123)

training <- part_data$p_0.7
test <- part_data$test
```
```{r}
#|label: cfa_all
# one factor
structure_k6_one <- psych::fa(training, nfactors = 1) |>
  efa_to_cfa()

# two factor model
structure_k6_two <- psych::fa(training, nfactors = 2) |>
  efa_to_cfa()

# three structure model
structure_k6_three <- psych::fa(training, nfactors = 3) %>%
  efa_to_cfa()

# inspect models
structure_k6_one
structure_k6_two
structure_k6_three
```


```{r}
#| label: fit-models
# fit and compare models
one_latent <- suppressWarnings(lavaan::cfa(structure_k6_one, data = test))
two_latents <- suppressWarnings(lavaan::cfa(structure_k6_two, data = test))
three_latents <- suppressWarnings(lavaan::cfa(structure_k6_three, data = test))

compare <- performance::compare_performance(one_latent, two_latents, three_latents, verbose = FALSE)

# view as html table
as.data.frame(compare)|>
  kbl(format = "markdown")
```

This table provides the results of three different Confirmatory Factor Analysis (CFA) models: one that specifies a single latent factor, one that specifies two latent factors, and one that specifies three latent factors. The results include a number of goodness-of-fit statistics, which can be used to assess how well each model fits the data.

#### One_latent Model: This model assumes that there is only one underlying latent factor contributing to all variables. This model has a chi-square statistic of 1359.7 with 14 degrees of freedom, which is highly significant (p<0.001), indicating a poor fit of the model to the data. Other goodness-of-fit indices like GFI, AGFI, NFI, NNFI, and CFI are all high (above 0.9), generally indicating good fit, but these indices can be misleading in the presence of large sample sizes. RMSEA is above 0.1 which indicates a poor fit. The SRMR is less than 0.08 which suggests a good fit, but given the high Chi-square and RMSEA values, we can't solely rely on this index. The Akaike information criterion (AIC), Bayesian information criterion (BIC) and adjusted BIC are used for comparing models, with lower values indicating better fit.

#### Two_latents Model: This model assumes that there are two underlying latent factors. The chi-square statistic is lower than the one-factor model (317.97 with 13 df), suggesting a better fit. The p-value is still less than 0.05, indicating a statistically significant chi-square, which typically suggests a poor fit. However, all other fit indices (GFI, AGFI, NFI, NNFI, and CFI) are above 0.9 and the RMSEA is 0.051, which generally indicate good fit. The SRMR is also less than 0.08 which suggests a good fit. This model has the lowest AIC and BIC values among the three models, indicating the best fit according to these criteria.

#### Three_latents Model: This model assumes three underlying latent factors. The chi-square statistic is 747.87 with 12 df, higher than the two-factor model, suggesting a worse fit to the data. Other fit indices such as GFI, AGFI, NFI, NNFI, and CFI are below 0.97 and the RMSEA is 0.083, which generally indicate acceptable but not excellent fit. The SRMR is less than 0.08 which suggests a good fit. The AIC and BIC values are higher than the two-factor model but lower than the one-factor model, indicating a fit that is better than the one-factor model but worse than the two-factor model.

Based on these results, the two-latents model seems to provide the best fit to the data among the three models, according to most of the fit indices and the AIC and BIC. Note, all models have significant chi-square statistics, which suggests some degree of misfit. It's also important to consider the substantive interpretation of the factors, to make sure the model makes sense theoretically. 




### Try with multiple groups


```{r}
#| label: group_by_cfa

# select the columns we need + ethnicity
dt_eth_k6_eth <- dt_start |> 
  filter(eth_cat == "euro" | eth_cat == "maori") |> 
  select(kessler_depressed, kessler_effort,kessler_hopeless,
                                 kessler_worthless, kessler_nervous,
                                 kessler_restless, eth_cat)



# remove ethnicity for traning data 




# first partition the data 
part_data_eth <- datawizard::data_partition(dt_eth_k6_eth, traing_proportion = .07, seed = 123, group = "eth_cat")

training_eth <- part_data_eth$p_0.7
test_eth <- part_data_eth$test


# fit and compare models for configural equivalence
one_latent_eth_configural <- suppressWarnings(lavaan::cfa(structure_k6_one, group = "eth_cat", data = test_eth))
two_latents_eth_configural <- suppressWarnings(lavaan::cfa(structure_k6_two, group = "eth_cat", data = test_eth))
three_latents_eth_configural <- suppressWarnings(lavaan::cfa(structure_k6_three, group = "eth_cat", data = test_eth))

compare_eth_configural <- performance::compare_performance(one_latent_eth_configural, two_latents_eth_configural, three_latents_eth_configural, verbose = FALSE)


# fit and compare models for metric equivalence
one_latent_eth_metric <- suppressWarnings(lavaan::cfa(structure_k6_one, group = "eth_cat", group.equal = "loadings", data = test_eth))
two_latents_eth_metric  <- suppressWarnings(lavaan::cfa(structure_k6_two, group = "eth_cat", group.equal = "loadings", data = test_eth))
three_latents_eth_metric  <- suppressWarnings(lavaan::cfa(structure_k6_three, group = "eth_cat",group.equal = "loadings", data = test_eth))

compare_eth_metric  <- performance::compare_performance(one_latent_eth_metric, 
                                                        two_latents_eth_metric, 
                                                        three_latents_eth_metric, 
                                                        verbose = FALSE)


# fit and compare models for scalar equivalence
one_latent_eth_scalar <- suppressWarnings(lavaan::cfa(structure_k6_one, group = "eth_cat", group.equal = c("loadings","intercepts"), data = test_eth))
two_latents_eth_scalar  <- suppressWarnings(lavaan::cfa(structure_k6_two, group = "eth_cat", group.equal =  c("loadings","intercepts"), data = test_eth))
three_latents_eth_scalar  <- suppressWarnings(lavaan::cfa(structure_k6_three, group = "eth_cat",group.equal =  c("loadings","intercepts"), data = test_eth))

compare_eth_scalar  <- performance::compare_performance(one_latent_eth_scalar, 
                                                        two_latents_eth_scalar, 
                                                        three_latents_eth_scalar, 
                                                        verbose = FALSE)


```

Recall, in the context of measurement and factor analysis, the concepts of *configural*, *metric*, and *scalar invariance* relate to the comparability of a measurement instrument, such as a survey or test, across different groups. 

We saw in part 1 of this course that these invariance concepts are frequently tested in the context of cross-cultural, multi-group, or longitudinal studies.

Let's first define these concepts, and then apply them to the context of the Kessler 6 (K6) Distress Scale used among Maori and New Zealand Europeans.

1. **Configural invariance** refers to the most basic level of measurement invariance, and it is established when the same pattern of factor loadings and structure is observed across groups. This means that the underlying constructs (factors) are defined the same way for different groups. This doesn't mean the strength of relationship between items and factors (loadings) or the item means (intercepts) are the same, just that the items relate to the same factors in all groups. 

In the context of the K6 Distress Scale, configural invariance would suggest that the same six items are measuring the construct of psychological distress in the same way for both Māori and New Zealand Europeans, even though the strength of the relationship between the items and the construct (distress), or the average scores, might differ.

2. **Metric invariance** (also known as "weak invariance") refers to the assumption that factor loadings are equivalent across groups, meaning that the relationship or association between the measured items and their underlying factor is the same in all groups. This is important when comparing the strength of relationships with other variables across groups. 

If metric invariance holds for the K6 Distress Scale, this would mean that a unit change in the latent distress factor would correspond to the same change in each item score (e.g., feeling nervous, hopeless, restless, etc.) for both Māori and New Zealand Europeans. 

3. **Scalar invariance** (also known as "strong invariance") involves equivalence of both factor loadings and intercepts (item means) across groups. This means that not only are the relationships between the items and the factors the same across groups (as with metric invariance), but also the zero-points or origins of the scales are the same. Scalar invariance is necessary when one wants to compare latent mean scores across groups.

In the context of the K6 Distress Scale, if scalar invariance holds, it would mean that a specific score on the scale would correspond to the same level of the underlying distress factor for both Māori and New Zealand Europeans. It would mean that the groups do not differ systematically in how they interpret and respond to the items. If this holds, one can make meaningful comparisons of distress level between Maori and New Zealand Europeans based on the scale scores.

Note: each of these levels of invariance is a progressively stricter test of the equivalence of the measurement instrument across groups. Demonstrating scalar invariance, for example, also demonstrates configural and metric invariance. On the other hand, failure to demonstrate metric invariance means that scalar invariance also does not hold. These tests are therefore usually conducted in sequence. The results of these tests should be considered when comparing group means or examining the relationship between a scale and other variables across groups.


### Configural invariance:



```{r}
as.data.frame(compare_eth_configural)|>
  kbl(format = "markdown")
```

The table represents the comparison of three multi-group confirmatory factor analysis (CFA) models conducted to test for configural invariance across different ethnic categories (eth_cat). Configural invariance refers to whether the pattern of factor loadings is the same across groups. It's the most basic form of measurement invariance.

Looking at the results, we can draw the following conclusions:

1. **Chi2 (Chi-square)**: A lower value suggests a better model fit. In this case, the two_latents_eth_configural model exhibits the lowest Chi2 value, suggesting it has the best fit according to this metric.

2. **GFI (Goodness of Fit Index) and AGFI (Adjusted Goodness of Fit Index)**: These values range from 0 to 1, with values closer to 1 suggesting a better fit. The two_latents_eth_configural model has the highest GFI and AGFI values, indicating it is the best fit according to these indices.

3. **NFI (Normed Fit Index), NNFI (Non-Normed Fit Index, also called TLI), CFI (Comparative Fit Index)**: These range from 0 to 1, with values closer to 1 suggesting a better fit. The one_latent_eth_configural model has the highest values, suggesting it is the best fit according to these metrics.

4. **RMSEA (Root Mean Square Error of Approximation)**: Lower values are better, with values below 0.05 considered good and up to 0.08 considered acceptable. In this table, the two_latents_eth_configural model has an RMSEA of 0.05, which falls within the acceptable range.

5. **RMR (Root Mean Square Residual) and SRMR (Standardized Root Mean Square Residual)**: Lower values are better, typically less than 0.08 is considered a good fit. All models exhibit acceptable RMR and SRMR values, with the two_latents_eth_configural model having the lowest.

6. **RFI (Relative Fit Index), PNFI (Parsimonious Normed Fit Index), IFI (Incremental Fit Index), RNI (Relative Noncentrality Index)**: These range from 0 to 1, with values closer to 1 suggesting a better fit. The one_latent_eth_configural model has the highest values, suggesting the best fit according to these measures.

7. **AIC (Akaike Information Criterion) and BIC (Bayesian Information Criterion)**: Lower values indicate a better fit when comparing models. The two_latents_eth_configural model has the lowest AIC and BIC, suggesting it is the best fit according to these criteria.

8. **p_Chi2 and p_RMSEA**: These are the significance levels for the Chi-square test and the RMSEA, respectively. Non-significant values (p > 0.05) suggest a good fit. Only the RMSEA for the two_latents_eth_configural model is non-significant, suggesting a good fit.

Overall, the two_latents_eth_configural model appears to provide the best fit across multiple indices, suggesting configural invariance (i.e., the same general factor structure) across ethnic categories with a two-factor solution. As with the previous assessment, theoretical soundness and other substantive considerations should also be taken into account when deciding on the final model.

### Metric Equivalence

```{r}
as.data.frame(compare_eth_metric)|>
  kbl(format = "markdown")
```

This table presents the results of a multi-group confirmatory factor analysis (CFA) conducted to test metric equivalence (also known as measurement invariance) across different ethnic categories (eth_cat). The models (one_latent_eth_metric, two_latents_eth_metric, three_latents_eth_metric) were run with a constraint of equal factor loadings across groups, which is a requirement for metric invariance.

Here's the interpretation of the fit indices:

1. **Chi2 (Chi-square)**: Lower values indicate better model fit. The two_latents_eth_metric model has the lowest Chi2 value, suggesting the best fit according to this measure.

2. **GFI (Goodness of Fit Index), AGFI (Adjusted Goodness of Fit Index)**: These range from 0 to 1, with values closer to 1 indicating a better fit. The two_latents_eth_metric model has the highest GFI and AGFI values, suggesting the best fit according to these indices.

3. **NFI (Normed Fit Index), NNFI (Non-Normed Fit Index, or TLI), CFI (Comparative Fit Index)**: These range from 0 to 1, with values closer to 1 indicating a better fit. For these indices, the one_latent_eth_metric model has the highest values, suggesting the best fit according to these measures.

4. **RMSEA (Root Mean Square Error of Approximation)**: Lower values are better, with values below 0.05 generally considered good, and values up to 0.08 considered acceptable. Only the two_latents_eth_metric model has an RMSEA within the acceptable range (0.051).

5. **RMR (Root Mean Square Residual) and SRMR (Standardized Root Mean Square Residual)**: Lower values are better, typically less than 0.08 is considered a good fit. All models have acceptable RMR and SRMR values, with the two_latents_eth_metric model having the lowest, indicating the best fit.

6. **RFI (Relative Fit Index), PNFI (Parsimonious Normed Fit Index), IFI (Incremental Fit Index), RNI (Relative Noncentrality Index)**: These range from 0 to 1, with values closer to 1 indicating better fit. The one_latent_eth_metric model has the highest values, suggesting the best fit according to these indices.

7. **AIC (Akaike Information Criterion) and BIC (Bayesian Information Criterion)**: Lower values indicate a better fit when comparing models. The two_latents_eth_metric model has the lowest AIC and BIC, indicating the best fit according to these criteria.

8. **p_Chi2 and p_RMSEA**: These are the significance levels for the Chi-square test and the RMSEA, respectively. Non-significant values (p > 0.05) suggest a good fit. Only the RMSEA for the two_latents_eth_metric model is non-significant, suggesting a good fit.

In summary, the two_latents_eth_metric model appears to provide the best fit overall, indicating that a two-factor solution might be appropriate and that the metric equivalence (equal factor loadings) assumption is supported across ethnic categories. However, one must also take into consideration the theoretical soundness of the model and other substantive considerations when deciding on the final model.


### Scalar Equivalence


```{r}
# view as html table
as.data.frame(compare_eth_scalar)|>
  kbl(format = "markdown")
```

The table presents the results of a multi-group confirmatory factor analysis (CFA) conducted to test scalar equivalence (also known as measurement invariance) across different ethnic categories (eth_cat). The models (one_latent_eth_scalar, two_latents_eth_scalar, three_latents_eth_scalar) were run with constraints on both factor loadings and intercepts to be equal across groups, a requirement for scalar invariance. 

Here's the interpretation of the fit indices:

1. **Chi2 (Chi-square)**: Lower values indicate better model fit. The two_latents_eth_scalar model has the lowest Chi2 value, suggesting the best fit according to this measure.

2. **GFI (Goodness of Fit Index), AGFI (Adjusted Goodness of Fit Index)**: These range from 0 to 1, with values closer to 1 indicating a better fit. The two_latents_eth_scalar model has the highest GFI and AGFI values, suggesting the best fit according to these indices.

3. **NFI (Normed Fit Index), NNFI (Non-Normed Fit Index, or TLI), CFI (Comparative Fit Index)**: These range from 0 to 1, with values closer to 1 indicating a better fit. The one_latent_eth_scalar model has the highest values, suggesting the best fit according to these measures.

4. **RMSEA (Root Mean Square Error of Approximation)**: Lower values are better, with values below 0.05 generally considered good, and values up to 0.08 considered acceptable. Only the two_latents_eth_scalar model has an RMSEA within the acceptable range (0.05).

5. **RMR (Root Mean Square Residual) and SRMR (Standardized Root Mean Square Residual)**: Lower values are better, typically less than 0.08 is considered a good fit. All models have acceptable RMR and SRMR values, with the two_latents_eth_scalar model having the lowest, indicating the best fit.

6. **RFI (Relative Fit Index), PNFI (Parsimonious Normed Fit Index), IFI (Incremental Fit Index), RNI (Relative Noncentrality Index)**: These range from 0 to 1, with values closer to 1 indicating better fit. The one_latent_eth_scalar model has the highest values, suggesting the best fit according to these indices.

7. **AIC (Akaike Information Criterion) and BIC (Bayesian Information Criterion)**: Lower values indicate a better fit when comparing models. The two_latents_eth_scalar model has the lowest AIC and BIC, indicating the best fit according to these criteria.

8. **p_Chi2 and p_RMSEA**: These are the significance levels for the Chi-square test and the RMSEA, respectively. Non-significant values (p > 0.05) suggest a good fit. Only the RMSEA for the two_latents_eth_scalar model is non-significant, suggesting a good fit.

In summary, the two_latents_eth_scalar model appears to provide the best fit overall, indicating that a two-factor solution might be appropriate and that the scalar equivalence (equal factor loadings and intercepts) assumption is supported across ethnic categories. However, one must also consider the theoretical soundness of the model and other substantive considerations when deciding on the final model.


Overall it seems that we have good evidence for the two-factor model of Kessler-6. 

Let's next get the data into shape for analysis. Here we create a variable for the two factors:

```{r}
#| label: extract_two_factors

# get two factors from data
dt_start2 <- dt_start |>
  arrange(id, wave) |>
  rowwise() |>
  mutate(
    kessler_latent_depression = mean(c(kessler_depressed, kessler_hopeless, kessler_effort), na.rm = TRUE),
    kessler_latent_anxiety  = mean(c(kessler_effort, kessler_nervous, kessler_restless), na.rm = TRUE)
  ) |> ungroup()

```


It is useful toinspect histograms

```{r}
#| label: histogram_kessler_anxiety
hist(dt_start2$kessler_latent_anxiety)
```


```{r}
#| label: histogram_kessler_depression
hist(dt_start2$kessler_latent_depression)
```


### Assess change in the exposure


Not this is just a description of the the summary scores. We do not assess change within indivuals 


```{r}
#| label: prepare_exposure_data
#  select only the baseline year and the exposure year.  That will give us change in the exposure. ()
dt_exposure <- dt_start2 |>

  # select baseline year and exposure year
  filter(wave == "2018" | wave == "2019") |>

  # select variables of interest
  select(id, wave, hours_exercise_coarsen,  eth_cat) |>

  # the categorical variable needs to be numeric for us to use msm package to investigate change
  mutate(hours_exercise_coarsen_n = as.numeric(hours_exercise_coarsen)) |>
  droplevels()


# check
dt_exposure |>
  tabyl(hours_exercise_coarsen_n, eth_cat,  wave )
```


I've written a function called `transition_table` that will help us assess change in the exposure at the individual level.


```{r}
#| label: transition_table
#   consider people going from active to vary active
out <- msm::statetable.msm(round(hours_exercise_coarsen_n, 0), id, data = dt_exposure)


# for a function I wrote to create state tables
state_names <- c("Inactive", "Somewhat Active", "Active", "Extremely Active")

# transition table

transition_table(out, state_names)
```

Next consider Māori only 

```{r}
#| label: maori_only_transition


# Maori only

dt_exposure_maori <- dt_exposure |>
  filter(eth_cat == "māori")

out_m <- msm::statetable.msm(round(hours_exercise_coarsen_n, 0), id, data = dt_exposure_maori)

# with this little support we might consider parametric models
t_tab_m<- transition_table( out_m, state_names)

#interpretation
cat(t_tab_m$explanation)
print(t_tab_m$table)

```


```{r}
#| label: euro_only_transition

# filter euro
dt_exposure_euro <- dt_exposure |>
  filter(eth_cat == "euro")

# model change
out_e <- msm::statetable.msm(round(hours_exercise_coarsen_n, 0), id, data = dt_exposure_euro)


# creat transition table.
t_tab_e <- transition_table( out_e, state_names)

#interpretation
cat(t_tab_e$explanation)

# table
print(t_tab_e$table)

```


Overall we find evidence for change in the exposure variable. This suggest that we are ready to proceed with the next step of causal estimation.


### Create wide data frame for analysis



```{r}
############## ############## ############## ############## ############## ############## ############## ########
####  ####  ####  CREATE DATA FRAME FOR ANALYSIS ####  ####  ################## ############## ######## #########
############## ############## ############## ############## ############## ############## ############# #########

# To find out more about our dataset go here:
# https://github.com/go-bayes/psych-434-2023/blob/main/data/readme.qmd


# I have created a function that will put the data into the correct shape. Here are the steps.

# Step 1: choose baseline variables (confounders).  here we select standard demographic variablees plus personality variables.

# note that the function will automatically include the baseline exposure and basline outcome in the baseline variable confounder set so you don't need to include these. 


# here are some plausible baseline confounders
baseline_vars = c(
  "edu",
  "male",
  "eth_cat",
  "employed",
  "gen_cohort",
  "nz_dep2018", # nz dep
  "nzsei13", # occupational prestige
  "partner",
  "parent",
  "pol_orient",
 # "rural_gch2018",
   "urban", # use the two level urban varaible. 
  "agreeableness",
  "conscientiousness",
  "extraversion",
  "honesty_humility",
  "openness",
  "neuroticism",
  "modesty",
  "religion_identification_level"
)


## Step 2, select the exposure variable.  This is the "cause"
exposure_var = c("hours_exercise_coarsen")


## step 3. select the outcome variable.  These are the outcomes.
outcome_vars_reflective = c("kessler_latent_anxiety",
                            "kessler_latent_depression")



# the function "create_wide_data" should be in your environment.
# If not, make sure to run the first line of code in this script once more.  You may ignore the warnings. or uncomment and run the code below
# source("https://raw.githubusercontent.com/go-bayes/templates/main/functions/funs.R")
dt_prepare <-
  create_wide_data(
    dat_long = dt_start2,
    baseline_vars = baseline_vars,
    exposure_var = exposure_var,
    outcome_vars = outcome_vars_reflective
  )


```



## Descriptive table 

I created a simple function

```{r}
# I have created a function that will allow you to take a data frame and
# create a table
# REDO

```


However, if would like like a nicer table, try this: 


```{r}
#| label: table_again

# get data into shape
dt_new <- dt_prepare %>%
  select(starts_with("t0")) %>%
  rename_all(~ stringr::str_replace(., "^t0_", "")) %>%
  mutate(wave = factor(rep("baseline", nrow(dt_prepare)))) |>
  janitor::clean_names(case = "screaming_snake")


# create a formula string

baseline_vars_names <- dt_new %>%
  select(-WAVE) %>%
  colnames()

table_baseline_vars <-
  paste(baseline_vars_names, collapse = "+")

formula_string_table_baseline <-
  paste("~", table_baseline_vars, "|WAVE")

table1::table1(as.formula(formula_string_table_baseline),
               data = dt_new,
               overall = FALSE)


# another method for making a table
# x <- table1::table1(as.formula(formula_string_table_baseline),
#                     data = dt_new,
#                     overall = FALSE)

# # some options, see: https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html
# table1::t1kable(x, format = "html", booktabs = TRUE) |>
#   kable_material(c("striped", "hover"))

```


Some more data wrangling. 


1. `mutate(id = factor(1:nrow(dt_prepare)))`: This creates a new column called `id` that has unique identification factors for each row in the dataset. It ranges from 1 to the number of rows in the dataset. 

2. The next `mutate` operation is used to convert the `t0_eth_cat`, `t0_urban`, and `t0_gen_cohort` variables to factor type, if they are not already. 

3. The `filter` command is used to subset the dataset to only include rows where the `t0_eth_cat` is either "euro" or "māori". The original dataset includes data with four different ethnic categories. This command filters out any row not related to these two groups.

4. `ungroup()` ensures that there's no grouping in the dataframe.

5. The `mutate(across(where(is.numeric), ~ scale(.x), .names = "{col}_z"))` step standardizes all numeric columns in the dataset by subtracting the mean and dividing by the standard deviation (a z-score transformation). The resulting columns are renamed to include "_z" at the end of their original names.

6. The `select` function is used to keep only specific columns: the `id` column, any columns that are factors, and any columns that end in "_z". 

7. The `relocate` functions re-order columns. The first `relocate` places the `id` column at the beginning. The next three `relocate` functions order the rest of the columns based on their names: those starting with "t0_" are placed before "t1_" columns, and those starting with "t2_" are placed after "t1_" columns.

8. `droplevels()` removes unused factor levels in the dataframe.

9. Finally, `skimr::skim(dt)` will print out a summary of the data in the `dt` object using the skimr package. This provides a useful overview of the data, including data types and summary statistics.

This function seems to be part of a data preparation pipeline in a longitudinal or panel analysis, where observations are ordered over time (indicated by t0_, t1_, t2_, etc.).

```{r}
### ### ### ### ### ### SUBGROUP DATA ANALYSIS: DATA WRANGLING  ### ### ### ###

dt <- dt_prepare|>
  mutate(id = factor(1:nrow(dt_prepare))) |>
  mutate(
  t0_eth_cat = as.factor(t0_eth_cat),
  t0_urban = as.factor(t0_urban),
  t0_gen_cohort = as.factor(t0_gen_cohort)
) |>
  dplyr::filter(t0_eth_cat == "euro" |
                t0_eth_cat == "māori") |> # Too few asian and pacific
  ungroup() |>
  # transform numeric variables into z scores (improves estimation)
  dplyr::mutate(across(where(is.numeric), ~ scale(.x), .names = "{col}_z")) %>%
  # select only factors and numeric values that are z-scores
  select(id, # category is too sparse
         where(is.factor),
         ends_with("_z"), ) |>
  # tidy data frame so that the columns are ordered by time (useful for more complex models)
  relocate(id, .before = starts_with("t1_"))   |>
  relocate(starts_with("t0_"), .before = starts_with("t1_"))  |>
  relocate(starts_with("t2_"), .after = starts_with("t1_")) |>
  droplevels()

# view object
skimr::skim(dt)


```

```{r}
#| label: more-data-checks
#| eval: false

# quick cross table
#table( dt$t1_hours_exercise_coarsen, dt$t0_eth_cat )

# checks
hist(dt$t2_kessler_latent_depression_z)
hist(dt$t2_kessler_latent_anxiety_z)

dt |>
  tabyl(t0_eth_cat, t1_hours_exercise_coarsen ) |>
  kbl(format = "markdown")

# Visualise missingness
naniar::vis_miss(dt)

# save your dataframe for future use

# make dataframe
dt = as.data.frame(dt)

# save data
saveRDS(dt, here::here("data", "dt"))

```


## Propensity scores


Next we generate propensity scores.  Instead of modelling the outcome (t2_y) we will model the exposure (t1_x) as predicted by baseline indicators (t0_c) that we assume may be associated with the outcome and the exposure.

The first  step is to obtain the baseline variables. note that we must remove "t0_eth_cat" because we are performing separate weighting for each stratum within this variable. 

```{r}
#| label: propensity_score prepare

# read -- you may start here if you need to repeat the analysis

dt <- readRDS(here::here("data", "dt"))

# get column names
baseline_vars_reflective_propensity <- dt|>
  dplyr::select(starts_with("t0"), -t0_eth_cat) |> colnames()

# define our exposure
X <- "t1_hours_exercise_coarsen"

# define subclasses
S <- "t0_eth_cat"

# Make sure data is in a data frame format
dt <- data.frame(dt)


# next we use our trick for creating a formula string, which will reduce our work
formula_str_prop <-
  paste(X,
        "~",
        paste(baseline_vars_reflective_propensity, collapse = "+"))

# this shows the exposure variable as predicted by the baseline confounders.
formula_str_prop

```



For propensity score analysis, we will try several different approaches.  We will want to select the method that produces the best balance. 

I typically use "ps" (classical propensity scores), `ebal` and `energy`.  The latter two in my experience yeild good balance. Also `energy` will work with *continuous* exposures. 

For more information, see [https://ngreifer.github.io/WeightIt/](https://ngreifer.github.io/WeightIt/)


```{r}
#| label: propensity_scores
#| eval: false


# traditional propensity scores-- note we select the ATT and we have a subgroup 
dt_match_ps <- match_mi_general(
  data = dt,
  X = X,
  baseline_vars = baseline_vars_reflective_propensity,
  subgroup = "t0_eth_cat",
  estimand = "ATE",
  method = "ps"
)

saveRDS(dt_match_ps, here::here("data", "dt_match_ps"))


# ebalance
dt_match_ebal <- match_mi_general(
  data = dt,
  X = X,
  baseline_vars = baseline_vars_reflective_propensity,
  subgroup = "t0_eth_cat",
  estimand = "ATE",
  method = "ebal"
)

# save output
saveRDS(dt_match_ebal, here::here("data", "dt_match_ebal"))



## energy balance method
# dt_match_energy <- match_mi_general(
#   data = dt,
#   X = X,
#   baseline_vars = baseline_vars_reflective_propensity,
#   subgroup = "t0_eth_cat",
#   estimand = "ATE",
#   #focal = "high", # for use with ATT
#   method = "energy"
# )
# saveRDS(dt_match_energy, here::here("data", "dt_match_energy"))
```



Results, first for Europeans 


```{r}
#| label: results_ps_analysis
#| 
dt_match_energy <- readRDS(here::here("data", "dt_match_energy"))
dt_match_ebal <- readRDS(here::here("data", "dt_match_ebal"))
dt_match_ps <- readRDS(here::here("data", "dt_match_ps"))

# next we inspect balance. "Max.Diff.Adj" should ideally be less than .05, but less than .1 is ok. This is the standardised mean difference. The variance ratio should be less than 2. 
# note that if the variables are unlikely to influence the outcome we can be less strict. 

#See: Hainmueller, J. 2012. “Entropy Balancing for Causal Effects: A Multivariate Reweighting Method to Produce Balanced Samples in Observational Studies.” Political Analysis 20 (1): 25–46. https://doi.org/10.1093/pan/mpr025.

# Cole SR, Hernan MA. Constructing inverse probability weights for marginal structural models. American Journal of
# Epidemiology 2008; 168(6):656–664.

# Moving towards best practice when using inverse probability of treatment weighting (IPTW) using the propensity score to estimate causal treatment effects in observational studies
# Peter C. Austin, Elizabeth A. Stuart
# https://onlinelibrary.wiley.com/doi/10.1002/sim.6607

bal.tab(dt_match_energy$euro)   #  good
bal.tab(dt_match_ebal$euro)   #  best
bal.tab(dt_match_ps$euro)   #  not as good
```


Results for Maori

```{r}
bal.tab(dt_match_energy$māori)   #  good
bal.tab(dt_match_ebal$māori)   #  best
bal.tab(dt_match_ps$māori)   #  not good

```





```{r}
#| label: love_plots
# code for summar
sum_e <- summary(dt_match_ebal$euro)
sum_m <- summary(dt_match_ebal$māori)


love_plot_e <- love.plot(dt_match_ebal$euro,
          binary = "std",
          thresholds = c(m = .1))+ labs(title = "NZ Euro PS: ebalance")

love_plot_m <- love.plot(dt_match_ebal$māori,
          binary = "std",
          thresholds = c(m = .1)) + labs(title = "Māori PS: ebalance")


library(patchwork)


love_plot_e / love_plot_m

```


 More data wrangling
 
 
```{r}

# prepare data post-weighting ---------------------------------------------


# prepare data
dt_ref_e <- subset(dt, t0_eth_cat == "euro") # original data subset only nz europeans

dt_ref_e$weights <- dt_match_ebal$euro$weights # get weights from the ps matching model,add to data

# prepare data
dt_ref_m <- subset(dt, t0_eth_cat == "māori")# original data subset only maori
dt_ref_m$weights <- dt_match_ebal$māori$weights # get weights from the ps matching model, add to data

# combine data into one data frame
dt_ref_all <- rbind(dt_ref_e, dt_ref_m) # combine the data into one dataframe. 

```

Let's consider a pseudo experiment where someome moves from inactive to active. 


```{r}
#| label: model_anxiety
#| eval: false

# we do not evaluate to save time
### SUBGROUP analysis
df <-  dt_ref_all
Y <-  "t2_kessler_latent_anxiety_z"
X <- "t1_hours_exercise_coarsen" # already defined above
baseline_vars = baseline_vars_reflective_propensity
treat_0 = "inactive"
treat_1 = "very_active"
estimand = "ATE"
scale = "RD"
nsims = 1000
family = "gaussian"
continuous_X = FALSE
splines = FALSE
cores = parallel::detectCores()
S = "t0_eth_cat"

# not we interact the subclass X treatment X covariates

formula_str <-
  paste(
    Y,
    "~",
    S,
    "*",
    "(",
    X ,
    "*",
    "(",
    paste(baseline_vars_reflective_propensity, collapse = "+"),
    ")",
    ")"
  )

# formula_str. # inspect on our own time 



# fit model
fit_all_all  <- glm(
  as.formula(formula_str),
  weights = weights,
  # weights = if (!is.null(weight_var)) weight_var else NULL,
  family = family,
  data = df
)

# simulate coefficients
conflicts_prefer(clarify::sim)
sim_model_all <- sim(fit_all_all, n = nsims, vcov = "HC0")

# simulate effect as modified in europeans
sim_estimand_all_e <- sim_ame(
  sim_model_all,
  var = X,
  cl = cores,
  subset = t0_eth_cat == "euro",
  verbose = FALSE
)

#rm(sim_estimand_all_e)
# note contrast of interest
sim_estimand_all_e <-
  transform(sim_estimand_all_e, RD = `E[Y(inactive)]` - `E[Y(very_active)]`)

#rm(sim_estimand_all_m)

# simulate effect as modified in māori
sim_estimand_all_m <- sim_ame(
  sim_model_all,
  var = X,
  cl = cores,
  subset = t0_eth_cat == "māori",
  verbose = FALSE
)

# combine
#m(sim_estimand_all_m)

sim_estimand_all_m <-
  transform(sim_estimand_all_m, RD = `E[Y(inactive)]` - `E[Y(very_active)]`)

# rearrange
names(sim_estimand_all_e) <-
  paste(names(sim_estimand_all_e), "e", sep = "_")

names(sim_estimand_all_m) <-
  paste(names(sim_estimand_all_m), "m", sep = "_")

est_all_anxiety <- cbind(sim_estimand_all_m, sim_estimand_all_e)
est_all_anxiety <- transform(est_all_anxiety, `RD_m - RD_e` = RD_m - RD_e)

saveRDS(est_all_anxiety, here::here("data","est_all_anxiety"))
# view summary
```

Calculate E-values

```{r}
#| label: summary_anxiety


# read data
est_all_anxiety <- readRDS( here::here("data","est_all_anxiety"))

# make dataframe
df_anxiety_all <- data.frame( summary(est_all_anxiety) )

table_estimates_anxiety <- df_anxiety_all |> 
    filter(row.names(df_anxiety_all) %in% c("RD_m", "RD_e")) |> 
    rename(lower_ci = `X2.5..`,
         upper_ci = `X97.5..`,
         estimate = Estimate) |> 
 # dplyr::mutate(standard_error = abs(`2.5 %` - `97.5 %`) / 3.92) |> 
  dplyr::mutate(across(where(is.numeric), round, digits = 3))


# note that I made a function to calculate the Evalue, load this with "experimental functions"
test_tab <- tab_ate_subgroup_rd(table_estimates_anxiety, delta = 1, sd = 1)
test_tab |> kbl(format = "markdown")
```

##  Differences by subgroups



```{r}
df_anxiety_all_plot <- df_anxiety_all |> 
 # filter(row.names(df_anxiety_all) %in% c("RD_m - RD_e")) |> 
    rename(lower_ci = `X2.5..`,
         upper_ci = `X97.5..`,
         estimate = Estimate) |> 
 # dplyr::mutate(standard_error = abs(`2.5 %` - `97.5 %`) / 3.92) |> 
  dplyr::mutate(across(where(is.numeric), round, digits = 3)) 

df_anxiety_all_plot

plot_sub_forest(df_anxiety_all_plot)
df_anxiety_all_plot|> 
  kbl(format = "html")
```

## Depression 

```{r}
#| eval: false
### SUBGROUP analysis
df <-  dt_ref_all
Y <-  "t2_kessler_latent_depression_z"
X <- "t1_hours_exercise_coarsen" # already defined above
baseline_vars = baseline_vars_reflective_propensity
treat_0 = "inactive"
treat_1 = "very_active"
estimand = "ATE"
scale = "RD"
nsims = 1000
family = "gaussian"
continuous_X = FALSE
splines = FALSE
cores = parallel::detectCores()
S = "t0_eth_cat"

# not we interact the subclass X treatment X covariates

formula_str <-
  paste(
    Y,
    "~",
    S,
    "*",
    "(",
    X ,
    "*",
    "(",
    paste(baseline_vars_reflective_propensity, collapse = "+"),
    ")",
    ")"
  )

# fit model
fit_all_dep  <- glm(
  as.formula(formula_str),
  weights = weights,
  # weights = if (!is.null(weight_var)) weight_var else NULL,
  family = family,
  data = df
)


# coefs <- coef(fit_all_dep)
# table(is.na(coefs))#   
# insight::get_varcov(fit_all_all)

# simulate coefficients
conflicts_prefer(clarify::sim)
sim_model_all <- sim(fit_all_dep, n = nsims, vcov = "HC1")


# simulate effect as modified in europeans
sim_estimand_all_e_d <- sim_ame(
  sim_model_all,
  var = X,
  cl = cores,
  subset = t0_eth_cat == "euro",
  verbose = FALSE
)


# note contrast of interest
sim_estimand_all_e_d <-
  transform(sim_estimand_all_e_d, RD = `E[Y(inactive)]` - `E[Y(very_active)]`)


# simulate effect as modified in māori
sim_estimand_all_m_d <- sim_ame(
  sim_model_all,
  var = X,
  cl = cores,
  subset = t0_eth_cat == "māori",
  verbose = FALSE
)

# combine
sim_estimand_all_m_d <-
  transform(sim_estimand_all_m_d, RD = `E[Y(inactive)]` - `E[Y(very_active)]`)


# summary
#summary(sim_estimand_all_e_d)
#summary(sim_estimand_all_m_d)

# rearrange
names(sim_estimand_all_e_d) <-
  paste(names(sim_estimand_all_e_d), "e", sep = "_")

names(sim_estimand_all_m_d) <-
  paste(names(sim_estimand_all_m_d), "m", sep = "_")


est_all_d <- cbind(sim_estimand_all_m_d, sim_estimand_all_e_d)
est_all_d <- transform(est_all_d, `RD_m - RD_e` = RD_m - RD_e)
saveRDS(est_all_d, here::here("data", "est_all_d"))
```



```{r}
est_all_d <- readRDS( here::here("data", "est_all_d"))

        
# make dataframe
df_dep <- data.frame( summary(est_all_d) )

table_estimates_depression <- df_dep |> 
    filter(row.names(df_dep) %in% c("RD_m", "RD_e")) |> 
    rename(lower_ci = `X2.5..`,
         upper_ci = `X97.5..`,
         estimate = Estimate) |> 
 # dplyr::mutate(standard_error = abs(`2.5 %` - `97.5 %`) / 3.92) |> 
  dplyr::mutate(across(where(is.numeric), round, digits = 3))


# note that I made a function to calculate the Evalue, load this with "experimental functions"
table_depression <- tab_ate_subgroup_rd(table_estimates_depression, delta = 1, sd = 1)
table_depression |> kbl(format = "markdown")
```


Summary

```{r}
# view summary
df_dep |> 
  kbl(format = "html")
# This table provides estimated levels of depression, in standard deviation units, for different levels of activity for two groups: Māori (indicated by "_m") and NZ Europeans (indicated by "_e").
#
# The expectations are named as `E[Y(<level of activity>)]_group`, where the level of activity can be `inactive`, `active`, or `very_active`.
#
# Here is a breakdown of the results.
#
#   1. For the Māori group (`_m`):
#
#   - `E[Y(inactive)]_m`: When inactive, the expected level of depression is 0.23 standard deviations, with a 95% confidence interval from 0.116 to 0.356.
# - `E[Y(active)]_m`: When active, the expected level of depression decreases to 0.193 standard deviations, with a 95% confidence interval from 0.108 to 0.282.
# - `E[Y(very_active)]_m`: When very active, the expected level of depression further decreases to 0.133 standard deviations, with a 95% confidence interval from 0.009 to 0.262.
# - `RD_m`: The risk difference (RD) between inactive and very active Māori individuals is 0.097 standard deviations, with a 95% confidence interval from -0.068 to 0.274. This indicates a decrease in depression when individuals move from an inactive to a very active lifestyle.
#
# 2. For the NZ European group (`_e`):
#
#   - `E[Y(inactive)]_e`: When inactive, the expected level of depression is 0.034 standard deviations, with a 95% confidence interval from -0.012 to 0.078.
# - `E[Y(active)]_e`: When active, the expected level of depression slightly decreases to -0.006 standard deviations, with a 95% confidence interval from -0.03 to 0.016.
# - `E[Y(very_active)]_e`: When very active, the expected level of depression further decreases to -0.046 standard deviations, with a 95% confidence interval from -0.086 to -0.007.
# - `RD_e`: The risk difference (RD) between inactive and very active NZ European individuals is 0.081 standard deviations, with a 95% confidence interval from 0.02 to 0.138. Similar to the Māori group, this indicates a decrease in depression when individuals move from an inactive to a very active lifestyle.
#
# The last row, `RD_m - RD_e`, represents the difference in risk differences between Māori and NZ Europeans. It's 0.017 standard deviations with a 95% confidence interval from -0.152 to 0.204. This is not statistically significant (the confidence interval contains 0), suggesting that the difference in depression reduction from being inactive to very active is not significantly different between the two groups.
#
# These are estimates and subject to statistical uncertainty. While they suggest a trend, the wide confidence intervals indicate that these estimates come with a degree of uncertainty.
```


```{r}
#| label: my_graph 

df_dep_plot_data <- df_dep |> 
 rename( lower_ci = `X2.5..`,
         upper_ci = `X97.5..`,
         estimate = Estimate) 


df_dep

plot_sub_forest <- function(df) {
  require(ggplot2)

  # Check if required packages are installed
  required_packages <- c("ggplot2")
  new_packages <- required_packages[!(required_packages %in% installed.packages()[, "Package"])]
  if (length(new_packages))
    stop("Missing packages: ", paste(new_packages, collapse = ", "))
  
  # Check if required columns are in the dataframe
  required_cols <- c("estimate", "lower_ci", "upper_ci")
  missing_cols <- required_cols[!(required_cols %in% colnames(df))]
  if (length(missing_cols) > 0)
    stop("Missing columns in dataframe: ", paste(missing_cols, collapse = ", "))
  
  # Order the factor levels by the estimate column in decreasing order
  
  ggplot(df, aes(x=estimate, y=factor(row.names(df)))) +
    geom_point() +
    geom_errorbarh(aes(xmin = lower_ci, xmax = upper_ci), height=0.3) +
    geom_vline(xintercept = 0, linetype="dashed", color = "red") +
    theme_bw() +
    xlab("Estimate") +
    ylab("")
}
plot_sub_forest(df_dep_plot_data)
```

